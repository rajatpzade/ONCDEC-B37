# **Introduction to DevOps**

## Day-1 ðŸ“Œ Overview
DevOps is a combination of **Development (Dev)** and **Operations (Ops)**.  
It focuses on collaboration, automation, and delivering software faster and more reliably.

![Alt Text](img/e404c522-8c6c-429a-b226-f8c98b9c3948.gif)
---

## ðŸš€ What is DevOps?
- A culture and set of practices
- Automates software development and deployment
- Reduces manual work
- Ensures faster and reliable releases
- Helps teams collaborate better

### ðŸ”¥ Key Principles of DevOps
- Continuous Integration (CI)
- Continuous Delivery/Deployment (CD)
- Infrastructure as Code (IaC)
- Monitoring & Logging
- Automation everywhere

---

# **How IT Company Works**

## ðŸ¢ Typical Department Workflow
An IT company usually has:

### 1ï¸âƒ£ **Business / Sales Team**
- Talks to clients  
- Understands requirements  
- Sends proposals & pricing  

### 2ï¸âƒ£ **Project Manager / Scrum Master**
- Plans project  
- Creates timelines  
- Assigns tasks  
- Ensures delivery  

### 3ï¸âƒ£ **Developers**
- Write application code  
- Implement new features  
- Fix bugs  

### 4ï¸âƒ£ **Testers / QA**
- Test application  
- Find bugs  
- Ensure quality before release  

### 5ï¸âƒ£ **DevOps / Operations**
- Create environments  
- Manage servers  
- Automate deployments  
- Monitor applications  
- Ensure uptime & performance  

### 6ï¸âƒ£ **Support Team**
- Handles live issues  
- Communicates with customers  

---

# **What is an Application?**

## ðŸ“Œ Simple Definition
An **application** is a software program designed to perform specific tasks for users.

### ðŸ§© Types of Applications
- **Web Applications** (Amazon, YouTube)
- **Mobile Applications** (WhatsApp, Instagram)
- **Desktop Applications** (VS Code, Chrome)
- **Backend Services / APIs**
- **Microservices**

### ðŸ›  Application Components
A typical application has:
- **Frontend** â†’ UI/UX (React, Angular)  
- **Backend** â†’ Logic (Java, Python, Node.js)  
- **Database** â†’ Data storage (MySQL, MongoDB)  

DevOps ensures these applications are deployed fast and run smoothly.

---

# **Developers vs Testers vs DevOps**

## ðŸ§‘â€ðŸ’» **Developers (Dev)**
- Write code  
- Build new features  
- Fix bugs  
- Commit code to Git  

### ðŸ”§ Tools Used:
- VS Code  
- Git  
- Programming languages  
- APIs  

---

## ðŸ§ª **Testers / QA**
- Test application quality  
- Report defects  
- Validate user experience  
- Perform manual/automation testing  

### ðŸ”§ Tools Used:
- Selenium  
- JMeter  
- Postman  
- TestRail  

---

## âš™ï¸ **DevOps Engineers**
- Automate builds, deployments & monitoring  
- Manage CI/CD pipelines  
- Handle servers & cloud (AWS)  
- Ensure production stability  

### ðŸ”§ Tools Used:
- Linux  
- Git & GitHub  
- Jenkins / GitHub Actions  
- Docker & Kubernetes  
- Terraform  
- AWS  
- Monitoring tools  

---

## ðŸ”¥ Simple Difference Table

| Role | Main Work | Goal | Tools |
|------|-----------|------|-------|
| **Developer** | Creates code | Build features | VS Code, Git, Languages |
| **Tester/QA** | Tests code | Ensure quality | Selenium, Postman |
| **DevOps** | Deploys & automates | Fast + stable delivery | Linux, GitHub Actions, AWS, Docker |

---

## ðŸŽ¯ Key Takeaway
- Developers **create** the application  
- Testers **ensure quality**  
- DevOps **deploys, automates & maintains** the application  

Together, they deliver software **faster, safer, and more efficiently**.

---




# **The Strategic Imperative of DevOps**

## Day-2 ðŸ“Œ Overview
This module explains why DevOps has become essential for modern IT, the importance of Linux and AWS, and the growing career opportunities in DevOps.

---

## ðŸ§ **Top Features of Linux**
- Open-source and free
- Highly secure and stable
- Lightweight and fast
- Excellent for servers and cloud environments
- Strong community support
- Powerful command-line interface

---

## ðŸŒ **Linux Everywhere**
- Runs on servers, cloud platforms, mobile devices, routers, IoT, and supercomputers  
- Backbone of the DevOps ecosystem  
- Used heavily in AWS, Kubernetes, Docker, and CI/CD pipelines  

---

## ðŸ”“ **Unlocking Linux Careers**
Career roles requiring Linux:
- DevOps Engineer  
- Cloud Engineer  
- SRE  
- System Administrator  
- Kubernetes Administrator  
- Security Engineer  

---

## â˜ï¸ **Why AWS Stands Out in the Cloud Market**
- First-mover advantage  
- Largest service offering (200+ services)  
- Global infrastructure  
- High reliability and performance  
- Massive customer base and ecosystem  
- Easy integration with DevOps tools  

---

## ðŸ§­ **Overview of AWS**
Key service categories:
- Compute (EC2, Lambda, ECS/Fargate)
- Storage (S3, EBS)
- Networking (VPC, Route 53)
- Databases (RDS, DynamoDB)
- IAM & Security
- Management & Monitoring (CloudWatch, CloudTrail)

---

## ðŸ† **Customer Success Stories**
AWS is trusted by:
- Netflix  
- Airbnb  
- LinkedIn  
- NASA  
- Samsung  
- Adobe  
Businesses leverage AWS for scalability, reliability, and reduced operational costs.

---

## ðŸ“ˆ **Scalability & Flexibility of Business with AWS**
- Auto Scaling  
- Elastic Load Balancing  
- Pay-as-you-go model  
- Handle traffic spikes without downtime  
- Easily expand globally  

---

## âš”ï¸ **Comparing AWS with Competitors**
| Feature | AWS | Azure | GCP |
|--------|-----|-------|------|
| Market Share | â­ Highest | High | Moderate |
| Services | â­ Most | Many | Fewer |
| Learning Curve | Easy | Medium | Medium |
| Ecosystem | â­ Strongest | Strong | Strong |

AWS leads due to maturity, stability & community support.

---

## ðŸ’¼ **Why DevOps Is a Growing Career Field**
- Companies want faster deployment  
- Need for automation  
- Rise of cloud computing  
- Increasing use of containers & Kubernetes  
- Continuous Integration & Continuous Delivery becoming standard  

---

## ðŸ“Š **High Demand for DevOps Professionals**
- Every tech-enabled company needs DevOps  
- Demand growing ~25â€“30% yearly  
- Shortage of skilled professionals = high salary  

---

## ðŸ’° **Salary Expectations & Career Growth**
Approximate salary ranges (India):
- Junior DevOps Engineer: â‚¹4â€“7 LPA  
- Mid-level DevOps Engineer: â‚¹8â€“15 LPA  
- Senior DevOps Engineer: â‚¹18â€“30+ LPA  
- Cloud/DevOps Architect: â‚¹30â€“50 LPA  

---

## ðŸ§  **Skills & Expertise in DevOps**
- Linux  
- Git & GitHub  
- CI/CD â€“ Jenkins, GitHub Actions  
- Cloud â€“ AWS  
- Docker & Kubernetes  
- Terraform  
- Monitoring â€“ Prometheus, Grafana  
- Scripting â€“ Bash, Python  

---

## ðŸŽ“ **Certifications & Learning Resources**
Recommended certifications:
- AWS Cloud Practitioner  
- AWS Solutions Architect Associate  
- Kubernetes CKA  
- Terraform Associate  
- Azure Fundamentals (optional)  

---

## ðŸš€ **The Future of DevOps Careers**
- AI + DevOps = AIOps  
- More automation & intelligent pipelines  
- Rising importance of SRE roles  
- Almost every company will move towards DevOps-driven workflows  

---

## ðŸŽ¯ **Goal to Achieve in CDEC**
By the end of this program, students will:
- Build strong Linux fundamentals  
- Master AWS essentials  
- Understand real-world DevOps workflows  
- Work with CI/CD tools  
- Deploy applications using Docker & Kubernetes  
- Prepare for DevOps interviews  
- Become job-ready for DevOps roles  

---
## Day-3 ðŸ“Œ Getting Started with Operating Systems
An **Operating System (OS)** is system software that manages hardware resources and allows applications to run smoothly.

---

## ðŸ§  Why Do We Need an OS?
- Manages CPU, RAM, Disk
- Runs applications
- Controls hardware
- Provides security
- Handles users & permissions
- Provides GUI & CLI

---

## ðŸ–¥ï¸ Different Types of Operating Systems
- Batch OS
- Time-Sharing OS
- Distributed OS
- Network OS
- Mobile OS
- Embedded OS
- Real-Time OS (RTOS)

---

## ðŸŒ How Operating Systems Impact Daily Life
Operating systems power:
- Laptops & Desktops
- Mobile phones
- ATMs
- Smart TVs
- Cars
- Servers
- Cloud platforms
- IoT devices

**Every digital service uses an OS.**

---

## âš”ï¸ Windows vs Unix vs Linux
| Feature | Windows | Unix | Linux |
|--------|---------|------|--------|
| Type | Closed Source | Proprietary | Open Source |
| Cost | Paid | Paid | Free |
| Security | Medium | High | Very High |
| Interface | GUI | CLI | CLI + GUI |
| Usage | Personal Use | Enterprise Servers | DevOps, Cloud |
| Customization | Low | Low | Very High |

---

## ðŸ›ï¸ Ownership and Origin
| OS | Owner | Year |
|----|--------|------|
| Windows | Microsoft | 1985 |
| Unix | AT&T Bell Labs | 1969 |
| Linux | Linus Torvalds | 1991 |

---

## ðŸ’° Cost and Licensing
- **Windows** â†’ Paid
- **Unix** â†’ Expensive
- **Linux** â†’ Free and open-source

---

## ðŸ” Security and Privacy
- Windows â†’ More prone to malware
- Unix â†’ Very strong permissions
- Linux â†’ Highly secure and stable

---

## ðŸ–¥ï¸ User Interface
- Windows â†’ GUI
- Unix â†’ CLI
- Linux â†’ CLI + Optional GUI

---

## ðŸ¢ What is a Server?
A **server** is a powerful computer that provides services to clients (web, database, files, applications).

---

## ðŸ–¥ï¸ Desktop OS vs Server OS
| Feature | Desktop OS | Server OS |
|--------|------------|------------|
| Purpose | Personal use | Hosting applications |
| GUI | Yes | Optional |
| Performance | Normal | High |
| Users | 1 user | Many clients |
| Examples | Windows 10, Ubuntu Desktop | RHEL, Ubuntu Server |

---

## ðŸ§ Introduction to Linux
Linux is an **open-source operating system kernel** widely used in DevOps, Cloud, and Servers.

### Why Linux for DevOps?
- Strong CLI
- Secure & stable
- Lightweight
- Server-friendly
- Used in AWS, Docker, Kubernetes

---

## ðŸ—ï¸ Architecture of Linux
Linux has five main layers:
- Hardware
- Kernel
- shell 
- User Applications

![Alt Text](img/Linux_arch.png)


### Kernel : 
    In simple terms, the Linux kernel is the core of the operating system that acts as a translator between software and hardware. It manages essential resources like the CPU and memory, and handles all communication, allowing applications to run without needing to know the specific details of the computer's hardware.  


### Shell :
```
A Linux shell is a program that acts as an interface between the user and the operating system's core, known as the kernel
```

### Hardware :

```
 Linux hardware is any physical component of a computer, like the CPU, RAM, and storage drives, that the Linux operating system manages and interacts

```

## Day-3 ðŸ“Œ Understanding the Linux Command Prompt
The **Linux command prompt** is where you type commands to interact with the operating system.  
It is the most powerful tool for DevOps engineers.

---

## ðŸ§© Decoding the Structure of the Command Prompt
A typical Linux prompt looks like this:

``
username@hostname:~$
``


**Breakdown:**
- `username` â†’ Current logged-in user  
- `@` â†’ Separator  
- `hostname` â†’ System name  
- `:` â†’ Separator  
- `~` â†’ Current directory (home directory)  
- `$` â†’ Normal user prompt (`#` for root user)

---

## ðŸ§­ Effective Command Prompt Usage: A Step-by-Step Guide
- Identify your **user** and **location**  
- Understand the **$** vs **#** prompt difference  
- Use **TAB** for auto-completion  
- Use **UP/DOWN arrows** to navigate history  
- Use **CTRL + C** to stop running commands  
- Use **clear** or **CTRL + L** to clean the screen  

---

## ðŸŽ¨ Making the Command Prompt Your Own (Advanced Customization)
You can customize your prompt by editing the PS1 variable.

Example:

`
PS1="\u@\h:\w$ "
`

Meaning:  
- `\u` â†’ Username  
- `\h` â†’ Hostname  
- `\w` â†’ Working directory  

*This topic is advanced; beginners can skip customization.*

---

## ðŸ§ Introduction to Linux Basic Commands
Here are the most commonly used beginner commands:

- `pwd` â†’ Show current directory  
- `ls` â†’ List files  
- `cd` â†’ Change directory  
- `clear` â†’ Clear terminal  
- `whoami` â†’ Show current user  
- `date` â†’ Show current date and time  
- `history` â†’ Show command history  
- `echo` â†’ Print text  

---

## ðŸ–¥ï¸ Getting Started with the Linux Terminal
The **terminal** is the interface where you type commands.

- GNOME Terminal  
- XTerm  
- Konsole  
- macOS Terminal  
- Windows WSL (for Linux on Windows)

How to open terminal:
- **Linux** â†’ CTRL + ALT + T  
- **Mac** â†’ Spotlight â†’ Terminal  
- **Windows (WSL)** â†’ wsl command  

---

## ðŸ§¾ Essential System Information Commands
- `uname -a` â†’ Complete system details  
- `hostname` â†’ Show system name  
- `uptime` â†’ System load & running time  
- `date` â†’ Current system date/time  
- `df -h` â†’ Disk usage  
- `du -sh` â†’ Size of a directory  
- `free -h` â†’ RAM usage  
- `top` â†’ Real-time processes  
- `who` â†’ Logged-in users  

---
## ðŸ“‚ Navigating the File System
Linux file system ek tree structure jaisa hota hai, jiska root `/` hota hai.

### ðŸ”¹ Basic Navigation Commands
- `pwd` â†’ Show current directory  
- `ls` â†’ List files  
- `ls -l` â†’ Detailed list  
- `ls -a` â†’ Show hidden files  
- `cd foldername` â†’ Enter a folder  
- `cd ..` â†’ Go one level back  
- `cd /` â†’ Go to root  
- `cd ~` â†’ Go to home  
- `cd /path/location` â†’ Go to specific path  

### ðŸ”¸ Example:

`pwd  `

`ls -l  `

`cd /etc  `

`cd ..  `

`cd ~  `


---

## ðŸ“ File and Directory Management

### ðŸ”¹ Creating Directories
`mkdir foldername  `
`mkdir -p a/b/c  `

### ðŸ”¹ Creating Files
`touch file.txt`

`touch file1 file2 file3 ` 

### ðŸ”¹ Copying Files
`cp file1 file2 `
 
`cp file.txt /path/location/` 

`cp -r folder1 folder2 `

### ðŸ”¹ Moving / Renaming Files
`mv oldname newname`  
`mv file.txt /path/ ` 

### ðŸ”¹ Deleting Files & Folders
`rm file.txt ` 
`rm -r foldername`  
`rm -rf foldername`   (âš ï¸ dangerous)  

---

## ðŸ“ Viewing and Editing Files

### ðŸ”¹ Viewing Content
`cat file.txt`  
`less file.txt`  
`head file.txt`  
tail file.txt  
`tail -f file.txt `  (live logs)  

### ðŸ”¹ Editing Files
`nano file.txt  `
`vi file.txt  `

### ðŸ”¸ Example:
`cat /etc/os-release ` 
`head -20 logs.txt`  
`tail -f /var/log/syslog ` 
`vim notes.txt ` 

---

## ðŸ“¦ Copy, Move, and Delete Files (Practical Examples)

### ðŸ”¹ Copy Examples
`cp index.html index-backup.html  `
`cp notes.txt /home/user/backup/ ` 
`cp -r project project-copy  `

### ðŸ”¹ Move / Rename Examples
`mv report.txt final-report.txt`  
`mv script.sh /usr/local/bin/`  
`mv *.txt documents/`  

### ðŸ”¹ Delete Examples
`rm temp.txt  `
`rm -r old-backup ` 
`rm -rf /tmp/testfolder`   (âš ï¸ irreversible)  

---

## â­ Real-Time DevOps Scenarios

### Scenario 1: Create a project structure  
`mkdir -p project/{src,logs,configs} ` 

### Scenario 2: Move a downloaded file  
`mv Downloads/file.sh project/scripts/  `

### Scenario 3: Check logs while deployment  
`tail -20 /var/log/app.log`  

### Scenario 4: Backup config before editing  
`cp nginx.conf nginx.conf.backup  `
`vim nginx.conf ` 


## ðŸŽ¯ The Significance of the Linux File System Hierarchy
- Organizes files in a predictable structure  
- Ensures security through permissions  
- Makes automation easy  
- Helps in troubleshooting logs, configs & binaries  
- Every directory ka apna specific purpose hota hai  

Example:  
- Config files hamesha `/etc` me honge  
- Logs hamesha `/var/log` me honge  
- User data `/home` ke andar hoga  

---

## ðŸ“ Inside the Linux Root Directory: What You Need to Know
Root directory `/` ke andar bahut saare **top-level folders** hote hain.  
Neeche unke important roles explain kiye gaye hain:

| Directory | Meaning | Example Usage |
|----------|---------|---------------|
| `/` | Root directory (top of the filesystem) | All other directories start from `/` |
| `/bin` | Essential user commands | ls, cp, mkdir |
| `/sbin` | System administration commands | reboot, fdisk |
| `/boot` | Bootloader files & kernel | vmlinuz, initrd.img |
| `/dev` | Device files | /dev/sda, /dev/tty |
| `/etc` | Configuration files | /etc/ssh/sshd_config |
| `/home` | User home directories | /home/rajat |
| `/lib` | Shared libraries for system | libc.so |
| `/media` | Auto-mounted removable media | Pendrive â†’ /media/usb |
| `/mnt` | Temporary mount point | Mount external HDD |
| `/opt` | Optional / third-party apps | Google Chrome, VMware |
| `/proc` | Virtual kernel & process info | /proc/cpuinfo |
| `/root` | Home directory of root user | /root/.ssh/ |
| `/run` | Temporary runtime data (boot time) | /run/docker.pid |
| `/srv` | Server-specific data | Web server data |
| `/sys` | Kernel info & device management | /sys/class/net |
| `/tmp` | Temporary files | Session cache |
| `/usr` | User applications & binaries | /usr/bin/python3 |
| `/var` | Variable files (logs, cache) | /var/log/syslog |
 

---

## ðŸ—‚ï¸ Understanding the Functionality of Common Linux Directories

### ðŸ”¹ `/bin`
Essential user commands:  
- `ls`  
- `cp`  
- `mv`  
- `cat`  

### ðŸ”¹ `/sbin`
System-level commands (root privileges required):  
- `shutdown`  
- `reboot`  
- `fdisk`  

### ðŸ”¹ `/etc`
Configuration files for applications & services:  
- `nginx.conf`  
- `fstab`  
- `ssh/sshd_config`  

### ðŸ”¹ `/home`
User-specific data (your personal files, documents, downloads).

### ðŸ”¹ `/var`
Frequently changing data:  
- `/var/log` â†’ System logs (`syslog`, `auth.log`)  
- `/var/www` â†’ Web server files  

### ðŸ”¹ `/tmp`
Temporary files that auto-delete after reboot.

### ðŸ”¹ `/usr`
User-installed applications and their libraries:  
- `/usr/bin`  
- `/usr/sbin`  
- `/usr/lib`

### ðŸ”¹ `/dev`
Device files representing hardware:  
- `/dev/sda` â†’ Hard disk  
- `/dev/tty` â†’ Terminal  

---
# ðŸ“ Vim Editor â€“ Complete Guide for DevOps Students

## ðŸ“˜ Overview of Vim and Its History
**Vim** (Vi IMproved) is a powerful, fast, and keyboard-focused text editor widely used in Linux environments.  
It originated from the classic Unix editor **vi**, created in 1976, and Vim was introduced in 1991 with enhanced features.

### â­ Why Vim?
- Extremely lightweight  
- Available by default in Linux/Unix servers  
- Ideal for editing configuration files  
- Fully keyboard-driven â†’ faster productivity  
- Trusted by system administrators and DevOps engineers  

---

# ðŸŽ¯ Basic Concepts: Modes in Vim

Vim operates using modes. Understanding them is essential.

### ðŸ”¹ 1. Command Mode (Default Mode)
- Used for navigation, delete, copy, paste, and shortcuts  
- You enter this mode by pressing `Esc`  

### ðŸ”¹ 2. Insert Mode
- Used for typing and editing text  
- Enter using: `i`, `I`, `a`, `A`, `o`, `O`

### ðŸ”¹ 3. Visual Mode
- Used for selecting text  
- Enter using: `v`, `V`, or `CTRL + v`

### ðŸ”¹ 4. Execute Mode (Command-Line Mode)
- Used for saving, quitting, searching, replacing  
- Enter using: `:`  

---

# ðŸ§­ Basic Navigation in Command Mode

### ðŸ”¹ Cursor Movement
- `h` â†’ Move left  
- `j` â†’ Move down  
- `k` â†’ Move up  
- `l` â†’ Move right  

### ðŸ”¹ Word Navigation
- `w` â†’ Next word  
- `b` â†’ Previous word  
- `e` â†’ End of word  

### ðŸ”¹ Line Navigation
- `0` â†’ Beginning of line  
- `$` â†’ End of line  

### ðŸ”¹ File Navigation
- `gg` â†’ Go to top of file  
- `G` â†’ Go to bottom of file  

---

# âœ‚ï¸ Text Manipulation in Command Mode

### ðŸ”¹ Delete Operations
- `x` â†’ Delete a character  
- `dd` â†’ Delete a line  
- `dw` â†’ Delete a word  
- `d$` â†’ Delete to end of line  

### ðŸ”¹ Copy (Yank)
- `yy` â†’ Copy a line  
- `yw` â†’ Copy a word  
- `y$` â†’ Copy to end of line  

### ðŸ”¹ Paste
- `p` â†’ Paste after cursor  
- `P` â†’ Paste before cursor  

### ðŸ”¹ Replace Text
- `r` â†’ Replace a single character  
- `R` â†’ Replace multiple characters continuously  

---

# â†©ï¸ Undo and Redo
- `u` â†’ Undo last action  
- `CTRL + r` â†’ Redo undone change  

---

# âœï¸ Entering Insert Mode

Insert mode allows actual typing.

### ðŸ”¹ Ways to Enter Insert Mode
- `i` â†’ Insert at cursor  
- `I` â†’ Insert at beginning of line  
- `a` â†’ Insert after cursor  
- `A` â†’ Insert at end of line  
- `o` â†’ Open new line below  
- `O` â†’ Open new line above  


## âŒ¨ï¸ Introduction to Linux Shortcuts: Boost Your Efficiency
Linux terminal shortcuts productivity ko boost karte hain.

### ðŸ”¹ Navigation Shortcuts
- `CTRL + A` â†’ Go to start of line  
- `CTRL + E` â†’ Go to end of line  
- `CTRL + U` â†’ Clear before cursor  
- `CTRL + K` â†’ Clear after cursor  

### ðŸ”¹ Command Execution Shortcuts
- `CTRL + C` â†’ Stop running command  
- `CTRL + L` â†’ Clear terminal  
- `UP ARROW` â†’ Previous command  
- `DOWN ARROW` â†’ Next command  
- `TAB` â†’ Auto complete  


## ðŸ“ Editing Text in Insert Mode

Inside insert mode:

- You can type normally  
- Arrow keys navigate text  
- `Backspace` deletes previous character  
- `CTRL + w` deletes previous word  
- `CTRL + u` deletes entire line before cursor  

---

## ðŸš¶ Navigating and Editing Inside Insert Mode

- Arrow keys â†’ Move cursor  
- `CTRL + h` â†’ Backspace  
- `CTRL + w` â†’ Delete previous word  
- `CTRL + u` â†’ Delete entire line  
- `CTRL + t` â†’ Increase indent  
- `CTRL + d` â†’ Decrease indent  

---

## ðŸšª Exiting Insert Mode

Press `Esc` â†’ to return to Command Mode  

From command mode you can:

- `:w` â†’ Save  
- `:q` â†’ Quit  
- `:wq` â†’ Save and quit  
- `:q!` â†’ Quit without saving  

---

## âš™ï¸ Entering Execute Mode

Execute mode is used to run file operations and advanced commands.

### ðŸ”¹ Enter Execute Mode
Press `:` (colon)

---

## ðŸ›  Executing Basic Commands

### ðŸ”¹ File Operations
- `:w` â†’ Save file  
- `:q` â†’ Quit  
- `:wq` â†’ Save & Quit  
- `:q!` â†’ Force quit without saving  

### ðŸ”¹ Searching
- `/word` â†’ Search downward  
- `?word` â†’ Search upward  
- `n` â†’ Next match  
- `N` â†’ Previous match  

### ðŸ”¹ Line Numbering
- `:set number` â†’ Enable line numbers  
- `:set nonumber` â†’ Disable line numbers  

---

## ðŸ” Entering Visual Mode

Types of Visual Mode:

- `v` â†’ Select characters  
- `V` â†’ Select entire lines  
- `CTRL + v` â†’ Block selection  

---

## âœ‚ï¸ Manipulating Text in Visual Mode

After selecting text:

- `d` â†’ Delete selection  
- `y` â†’ Copy selection  
- `p` â†’ Paste  
- `>` â†’ Indent  
- `<` â†’ Remove indent  

### ðŸ”¸ Example
```bash
v
(move cursor to select text)
y
p
````

# ðŸ‘¥ User and Permission Management in Linux

## Day-9 ðŸ“Œ Overview
User and permission management is crucial for Linux security and system administration.  
DevOps engineers must understand how to manage users, groups, and file permissions effectively.

---

## ðŸ‘¤ Types of Users in Linux

Linux has **three types of users**:

### ðŸ”¹ 1. Root User
- **UID (User ID)**: 0  
- **Privileges**: Full system access  
- **Prompt**: `#` (hash)  
- **Purpose**: System administration  
- **Example**: `root@server:~#`  

### ðŸ”¹ 2. System Users
- **UID Range**: 1-999  
- **Purpose**: Used by system processes & services (not human users)  
- **Examples**: `mysql`, `nginx`, `postgres`, `docker`  
- **Prompt**: `$`  

### ðŸ”¹ 3. Regular Users
- **UID Range**: 1000+  
- **Purpose**: Human users who log into the system  
- **Privileges**: Limited (only own files & directories)  
- **Prompt**: `$` (dollar sign)  
- **Example**: `rajat@server:~$`  

---

## ðŸ“Š Comparing User Types

| User Type | UID Range | Purpose | Prompt |
|-----------|-----------|---------|--------|
| **Root** | 0 | Full system control | `#` |
| **System** | 1-999 | Services & processes | `$` |
| **Regular** | 1000+ | Normal users | `$` |

---

## ðŸ”¨ Using the `useradd` Command

The `useradd` command creates new users in Linux.

### ðŸ”¹ Basic Syntax
```bash
sudo useradd [options] username
```

### ðŸ”¹ Common Options
- `-m` â†’ Create home directory  
- `-s /bin/bash` â†’ Assign shell  
- `-d /path` â†’ Specify home directory  
- `-g groupname` â†’ Assign primary group  
- `-G groupname` â†’ Assign secondary groups  
- `-u UID` â†’ Specify user ID  
- `-c "Real Name"` â†’ Add comment/full name  

---

## ðŸ“ Creating Users: Practical Examples

### ðŸ”¸ Example 1: Create a simple user
```bash
sudo useradd rajat
```
**What happens?**
- User `rajat` is created  
- No home directory (unless `-m` is used)  

---

### ðŸ”¸ Example 2: Create user with home directory
```bash
sudo useradd -m rajat
```
**What happens?**
- User `rajat` is created  
- Home directory `/home/rajat` is created automatically  

---

### ðŸ”¸ Example 3: Create user with shell and comment
```bash
sudo useradd -m -s /bin/bash -c "Rajat Kumar" rajat
```
**What happens?**
- User `rajat` created  
- Home directory: `/home/rajat`  
- Shell: `/bin/bash`  
- Full name: "Rajat Kumar"  

---

### ðŸ”¸ Example 4: Create user with specific UID
```bash
sudo useradd -m -u 1500 devops_user
```
**What happens?**
- User created with custom UID 1500  

---

### ðŸ”¸ Example 5: Create user and assign to group
```bash
sudo useradd -m -g developers -G docker,sudo alice
```
**What happens?**
- User `alice` created  
- Primary group: `developers`  
- Secondary groups: `docker`, `sudo`  

---

## ðŸ” Setting User Passwords

After creating a user, you must set a password.

### ðŸ”¹ Using the `passwd` Command

#### Syntax:
```bash
sudo passwd username
```

---

### ðŸ”¸ Example 1: Set password for a user
```bash
sudo passwd rajat
```
**Output:**
```
New password: [type password]
Retype new password: [confirm password]
passwd: password updated successfully
```

---

### ðŸ”¸ Example 2: Force user to change password on first login
```bash
sudo passwd -e rajat
```
**What happens?**
- User must change password on next login  

---

### ðŸ”¸ Example 3: Lock a user account
```bash
sudo passwd -l john
```
**What happens?**
- User `john` cannot login  
- Password is locked with `!`  

---

### ðŸ”¸ Example 4: Unlock a user account
```bash
sudo passwd -u john
```
**What happens?**
- User `john` can login again  

---

## ðŸ‘¥ Managing User Groups

Groups are used to organize users and assign permissions collectively.

### ðŸ”¹ Viewing Groups
```bash
cat /etc/group
```
**Output:**
```
root:x:0:
sudo:x:27:rajat,alice
docker:x:999:rajat
developers:x:1001:alice,bob
```

---

### ðŸ”¹ Creating Groups
```bash
sudo groupadd groupname
```

#### ðŸ”¸ Example 1: Create a simple group
```bash
sudo groupadd developers
```

#### ðŸ”¸ Example 2: Create a group with specific GID
```bash
sudo groupadd -g 2000 devops_team
```

---

### ðŸ”¹ Adding User to Group

#### Syntax:
```bash
sudo usermod -aG groupname username
```

#### ðŸ”¸ Example 1: Add user to sudo group
```bash
sudo usermod -aG sudo rajat
```
**What happens?**
- User `rajat` can now run commands with `sudo`  

---

#### ðŸ”¸ Example 2: Add user to docker group
```bash
sudo usermod -aG docker rajat
```
**What happens?**
- User `rajat` can run Docker commands without `sudo`  

---

#### ðŸ”¸ Example 3: Add user to multiple groups
```bash
sudo usermod -aG docker,developers,sudo rajat
```
**What happens?**
- User `rajat` added to three groups  

---

### ðŸ”¹ Viewing User's Groups
```bash
groups username
```

#### ðŸ”¸ Example:
```bash
groups rajat
```
**Output:**
```
rajat : rajat docker developers sudo
```

---

### ðŸ”¹ Removing User from Group
```bash
sudo delgroup username groupname
```

#### ðŸ”¸ Example:
```bash
sudo delgroup rajat docker
```
**What happens?**
- User `rajat` removed from `docker` group  

---

## ðŸ—‘ï¸ Removing Users

### ðŸ”¹ Delete User (keep home directory)
```bash
sudo userdel username
```

#### ðŸ”¸ Example:
```bash
sudo userdel john
```
**What happens?**
- User `john` deleted  
- Home directory `/home/john` still exists  

---

### ðŸ”¹ Delete User with Home Directory
```bash
sudo userdel -r username
```

#### ðŸ”¸ Example:
```bash
sudo userdel -r john
```
**What happens?**
- User `john` deleted  
- Home directory `/home/john` deleted  

---

## ðŸ“„ Introduction to Affected Files

User and group information is stored in specific files:

### ðŸ”¹ `/etc/passwd`
Stores user account information.

#### ðŸ”¸ Example:
```bash
cat /etc/passwd
```

**Output:**
```
root:x:0:0:root:/root:/bin/bash
rajat:x:1000:1000:Rajat Kumar:/home/rajat:/bin/bash
john:x:1001:1001:John Doe:/home/john:/bin/bash
mysql:x:111:113:MySQL Server:/var/lib/mysql:/bin/false
```

**Format:**
```
username:x:UID:GID:Full Name:Home Directory:Shell
```

---

### ðŸ”¹ `/etc/shadow`
Stores encrypted passwords (only root can read).

#### ðŸ”¸ View shadow file:
```bash
sudo cat /etc/shadow
```

**Output:**
```
root:!:18305:0:99999:7:::
rajat:$6$abc123....:18305:0:99999:7:::
john:!:18305:0:99999:7:::
```

---

### ðŸ”¹ `/etc/group`
Stores group information.

#### ðŸ”¸ Example:
```bash
cat /etc/group
```

**Output:**
```
root:x:0:
sudo:x:27:rajat,alice
docker:x:999:rajat
developers:x:1001:alice,bob
```

**Format:**
```
groupname:x:GID:members
```

---

## ðŸ  User Home Directories

Each user has a personal home directory.

### ðŸ”¹ Default Home Directory Location
```bash
/home/username
```

### ðŸ”¹ Special Home Directories
- **Root user**: `/root`  
- **Regular users**: `/home/username`  
- **System users**: Varies (e.g., `/var/lib/mysql` for mysql)  

---

### ðŸ”¸ Example: View your home directory
```bash
pwd
```
**Output (if logged in as rajat):**
```
/home/rajat
```

---

### ðŸ”¸ Example: Go to home directory
```bash
cd ~
```

---

### ðŸ”¸ Example: List files in home directory
```bash
ls -la ~
```

---

## âš™ï¸ Configuration Files

Key configuration files for user & group management:

### ðŸ”¹ `/etc/login.defs`
Controls default settings for user creation.

### ðŸ”¹ `/etc/default/useradd`
Stores default values for the `useradd` command.

#### ðŸ”¸ View defaults:
```bash
cat /etc/default/useradd
```

**Output:**
```
GROUP=100
HOME=/home
SHELL=/bin/sh
SKEL=/etc/skel
```

---

## ðŸ”„ Switching Between Users in Linux

### ðŸ”¹ Using the `su` Command

`su` = **switch user**

#### Syntax:
```bash
su [username]
```

---

### ðŸ”¸ Example 1: Switch to root user
```bash
su
```
**What happens?**
- Prompts for root password  
- Once authenticated, you become root  
- Prompt changes to `#`  

---

### ðŸ”¸ Example 2: Switch to specific user
```bash
su rajat
```
**What happens?**
- You switch to user `rajat`  
- Prompts for rajat's password  
- Prompt shows `rajat@hostname:~$`  

---

### ðŸ”¸ Example 3: Login as user with login shell
```bash
su - rajat
```
**What happens?**
- Switches to `rajat`  
- Loads rajat's environment variables  
- Better for security  

---

### ðŸ”¹ Exit from switched user
```bash
exit
```
**What happens?**
- Returns to previous user  

---

## ðŸ¦¸ Using the `sudo` Command

`sudo` = **superuser do**

Allows regular users to run commands with elevated privileges **without switching users**.

### ðŸ”¹ Basic Syntax
```bash
sudo command
```

---

### ðŸ”¸ Example 1: Run a command as root
```bash
sudo apt update
```
**What happens?**
- Command runs with root privileges  
- Prompts for current user's password (not root)  

---

### ðŸ”¸ Example 2: Create a file as root
```bash
sudo touch /etc/myconfig.conf
```
**What happens?**
- File created in `/etc` with root ownership  
- You remain logged in as regular user  

---

### ðŸ”¸ Example 3: Edit a system file
```bash
sudo nano /etc/hostname
```
**What happens?**
- Opens file editor with root privileges  
- You can save changes to protected files  

---

### ðŸ”¹ Checking sudo privileges
```bash
sudo -l
```
**Output example:**
```
User rajat may run the following commands on server:
    (ALL) ALL
```

---

## ðŸ“‹ Comparing `su` vs `sudo`

| Feature | `su` | `sudo` |
|---------|------|-------|
| **Switches user?** | Yes (full switch) | No (runs single command) |
| **Password** | Target user's password | Current user's password |
| **Overhead** | High (new shell) | Low (single command) |
| **Security** | Less secure | More secure |
| **Log trail** | Minimal | Detailed logging |
| **Use case** | Full system access | One-off privileged tasks |

---

## â­ Real-World DevOps Scenarios

### ðŸ”¸ Scenario 1: Add a new DevOps engineer to the team
```bash
# Create user
sudo useradd -m -s /bin/bash -c "Alice DevOps" alice

# Set password
sudo passwd alice

# Add to docker group (for container work)
sudo usermod -aG docker alice

# Add to sudo group (for admin access)
sudo usermod -aG sudo alice

# Verify
groups alice
```

---

### ðŸ”¸ Scenario 2: Create a deployment user for CI/CD
```bash
# Create deployment user
sudo useradd -m -s /bin/bash deployer

# Set password
sudo passwd deployer

# Add to docker group
sudo usermod -aG docker deployer

# Allow sudo without password (add to sudoers)
# Note: Use 'visudo' for safe editing
```

---

### ðŸ”¸ Scenario 3: Remove a user after they leave
```bash
# Remove user and home directory
sudo userdel -r john

# Remove from all groups (if not deleted)
# Already handled by userdel -r
```

---

### ðŸ”¸ Scenario 4: Give temporary sudo access
```bash
# Add user to sudo group
sudo usermod -aG sudo contractor

# After work is done, remove
sudo delgroup contractor sudo
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Root user** (UID 0) has full system access  
âœ… **System users** (1-999) run background services  
âœ… **Regular users** (1000+) are human users  
âœ… Use `useradd -m -s /bin/bash` to create users properly  
âœ… Always set passwords with `sudo passwd`  
âœ… Manage groups with `usermod -aG`  
âœ… Use `sudo` for security (not `su`)  
âœ… Check `/etc/passwd`, `/etc/shadow`, `/etc/group` for user info  

---

## ðŸ“ Quick Reference Commands

```bash
# Create user with home directory
sudo useradd -m username

# Set password
sudo passwd username

# Add user to group
sudo usermod -aG groupname username

# View user's groups
groups username

# Create a group
sudo groupadd groupname

# Delete user (keep home)
sudo userdel username

# Delete user (remove home)
sudo userdel -r username

# Switch user
su - username

# Run command as sudo
sudo command

# Check sudo privileges
sudo -l
```
// ...existing code...

---

# ðŸ” Password Security and Advanced User Management

## Day-10 ðŸ“Œ Overview
Password security is the foundation of Linux system security.  
Understanding password policies, account locking, and advanced group management is essential for DevOps engineers.

---

## ðŸ”‘ Importance of Password Security

### Why Strong Passwords Matter?
- **Prevents unauthorized access** to systems and data  
- **Protects sensitive information** from attackers  
- **Ensures compliance** with security standards  
- **Reduces risk** of data breaches  
- **Maintains system integrity** in production environments  

### ðŸ”¸ Strong Password Characteristics
- Minimum **12 characters** long  
- Mix of **uppercase, lowercase, numbers, and symbols**  
- **Not based on dictionary words**  
- **Not easily guessable** (avoid birthdays, names)  
- **Unique** (different for each account)  

### âš ï¸ Common Password Mistakes to Avoid
- Using simple passwords like `password123`  
- Reusing passwords across multiple accounts  
- Writing passwords on sticky notes  
- Sharing passwords with colleagues  
- Using default passwords  

---

## ðŸ” Using the `passwd` Command

The `passwd` command is the primary tool for password management in Linux.

### ðŸ”¹ Basic Syntax
```bash
sudo passwd username
```

---

### ðŸ”¸ Example 1: Change your own password
```bash
passwd
```
**What happens?**
- You're prompted for current password  
- Then prompted to enter new password twice  
- Output: `passwd: password updated successfully`

---

### ðŸ”¸ Example 2: Change another user's password (as root)
```bash
sudo passwd rajat
```
**What happens?**
- Root can change any user's password  
- Doesn't require old password verification  

---

### ðŸ”¸ Example 3: Force password change on next login
```bash
sudo passwd -e rajat
```
**What happens?**
- User `rajat` must change password at next login  
- Login prompt: `You are required to change your password immediately`  

---

### ðŸ”¸ Example 4: Lock a user account
```bash
sudo passwd -l rajat
```
**What happens?**
- User `rajat` cannot login  
- A `!` is added to the password hash in `/etc/shadow`  
- Error message: `Authentication token manipulation error`  

---

### ðŸ”¸ Example 5: Unlock a user account
```bash
sudo passwd -u rajat
```
**What happens?**
- User `rajat` can login again  
- The `!` prefix is removed from password hash  

---

### ðŸ”¸ Example 6: Disable login without removing password
```bash
sudo passwd -l rajat
sudo usermod -s /usr/sbin/nologin rajat
```
**What happens?**
- User cannot login interactively  
- But can still be used for system processes  

---

## ðŸ“‹ Password Policy Settings

Password policies enforce security standards across the system.

### ðŸ”¹ `/etc/login.defs` Configuration
This file contains default password policies.

#### ðŸ”¸ View password policies:
```bash
cat /etc/login.defs | grep PASS
```

**Output:**
```
PASS_MAX_DAYS   99999
PASS_MIN_DAYS   0
PASS_WARN_AGE   7
PASS_MIN_LEN    5
```

### ðŸ”¹ Understanding Policy Fields

| Field | Meaning | Default | Example |
|-------|---------|---------|---------|
| `PASS_MAX_DAYS` | Max days password valid | 99999 | 90 days |
| `PASS_MIN_DAYS` | Min days before changing | 0 | 1 day |
| `PASS_WARN_AGE` | Days before expiry warning | 7 | 14 days |
| `PASS_MIN_LEN` | Minimum password length | 5 | 12 chars |

---

### ðŸ”¸ Example 1: Set password to expire every 90 days
Edit `/etc/login.defs`:
```bash
sudo nano /etc/login.defs
```

Change:
```
PASS_MAX_DAYS   90
```

---

### ðŸ”¸ Example 2: Require minimum 12 character passwords
```bash
sudo nano /etc/login.defs
```

Change:
```
PASS_MIN_LEN    12
```

---

### ðŸ”¹ Using `pam_pwquality` for Strong Passwords

Install password quality checker:
```bash
sudo apt install libpam-pwquality
```

---

## ðŸ”’ Account Locking and Expiration

### ðŸ”¹ Using `chage` Command

`chage` = **change age** - manages password expiration and account lockout.

#### Syntax:
```bash
sudo chage [options] username
```

---

### ðŸ”¸ Example 1: View password aging info
```bash
sudo chage -l rajat
```

**Output:**
```
Last password change                    : Dec 08, 2025
Password expires                        : never
Password inactive                       : never
Account expires                         : never
Minimum number of days between changes  : 0
Maximum number of days between changes  : 99999
Number of days of warning before expiry : 7
```

---

### ðŸ”¸ Example 2: Set password to expire in 90 days
```bash
sudo chage -M 90 rajat
```
**What happens?**
- Password must be changed every 90 days  

---

### ðŸ”¸ Example 3: Set minimum days between password changes
```bash
sudo chage -m 1 rajat
```
**What happens?**
- User must wait at least 1 day before changing password again  

---

### ðŸ”¸ Example 4: Set password expiration warning
```bash
sudo chage -W 14 rajat
```
**What happens?**
- User gets warning 14 days before password expires  

---

### ðŸ”¸ Example 5: Set account expiration date
```bash
sudo chage -E 2026-12-31 rajat
```
**What happens?**
- Account `rajat` will be disabled on December 31, 2026  
- User cannot login after this date  

---

### ðŸ”¸ Example 6: Set all password policies at once
```bash
sudo chage -M 90 -m 1 -W 14 -I 7 rajat
```
**What happens?**
- Max days: 90  
- Min days: 1  
- Warning: 14 days  
- Inactive: 7 days  

---

## ðŸ“„ Understanding `/etc/shadow` Fields

The `/etc/shadow` file stores encrypted passwords and expiration details.

### ðŸ”¹ View shadow file (as root only):
```bash
sudo cat /etc/shadow
```

**Output:**
```
root:$6$xyz123abc....$:18305:0:99999:7:0:0:
rajat:$6$abc456def....$:18305:0:99999:7:7:18310:
john:!:18305:0:99999:7:0:0:
```

---

### ðŸ”¹ Shadow File Format
```
username:password_hash:lastchange:min:max:warn:inactive:expire:reserved
```

---

### ðŸ”¹ Understanding Each Field

| Field | Position | Meaning | Example |
|-------|----------|---------|---------|
| Username | 1 | User account name | `rajat` |
| Password Hash | 2 | Encrypted password | `$6$...` |
| Last Change | 3 | Days since 1970-01-01 | `18305` |
| Min Days | 4 | Min days before change | `0` |
| Max Days | 5 | Max days password valid | `99999` |
| Warning Days | 6 | Days before warning | `7` |
| Inactive Days | 7 | Days after expiry to lock | `7` |
| Expire Date | 8 | Account expiration days | `18310` |
| Reserved | 9 | Reserved field | (blank) |

---

### ðŸ”¸ Example: Decoding a shadow entry
```
rajat:$6$abc123...:18305:1:90:14:7:18310:
```

**Meaning:**
- Username: `rajat`  
- Password: Encrypted (starts with `$6$` = SHA-512)  
- Last changed: Day 18305 (around Dec 2024)  
- Must wait 1 day before next change  
- Password expires every 90 days  
- Warning given 14 days before expiry  
- Account locked 7 days after expiry  
- Account expires on day 18310 (around Jan 2025)  

---

## â° Using `chage` Command (Advanced)

### ðŸ”¹ Common `chage` Options

| Option | Meaning |
|--------|---------|
| `-l` | List password aging info |
| `-M` | Maximum days password valid |
| `-m` | Minimum days before change |
| `-W` | Warning days before expiry |
| `-I` | Inactive days after expiry |
| `-E` | Account expiration date |
| `-d` | Last password change date |

---

### ðŸ”¸ Example 1: Force password change immediately
```bash
sudo chage -d 0 rajat
```
**What happens?**
- User must change password on next login  

---

### ðŸ”¸ Example 2: View all users with expired passwords
```bash
sudo chage -l rajat | grep "Password expires"
```

---

### ðŸ”¸ Example 3: Set account to never expire
```bash
sudo chage -E -1 rajat
```
**What happens?**
- Account will never expire  

---

### ðŸ”¸ Example 4: Create comprehensive password policy
```bash
sudo chage -M 90 -m 1 -W 14 -I 7 -E 2026-12-31 rajat
```

**Policy Details:**
- Change password every 90 days  
- Wait 1 day minimum between changes  
- Warn 14 days before expiry  
- Lock after 7 days of inactivity  
- Account expires Dec 31, 2026  

---

# ðŸ‘¥ Introduction to Linux Groups (Advanced)

Groups are essential for managing permissions and organizing users efficiently.

---

## ðŸ“‹ Fields of `/etc/group`

The `/etc/group` file stores group information.

### ðŸ”¹ View group file:
```bash
cat /etc/group
```

**Output:**
```
root:x:0:
sudo:x:27:rajat,alice
docker:x:999:rajat,bob
developers:x:1001:alice,john,rajat
```

---

### ðŸ”¹ Group File Format
```
groupname:password:GID:members
```

---

### ðŸ”¹ Understanding Each Field

| Field | Position | Meaning | Example |
|-------|----------|---------|---------|
| Group Name | 1 | Name of group | `developers` |
| Password | 2 | Group password (x = shadow) | `x` |
| GID | 3 | Group ID number | `1001` |
| Members | 4 | Users in group (comma-separated) | `alice,john,rajat` |

---

### ðŸ”¸ Example: Decoding a group entry
```
developers:x:1001:alice,john,rajat
```

**Meaning:**
- Group name: `developers`  
- Password: Stored in `/etc/gshadow` (indicated by `x`)  
- GID: 1001 (unique identifier)  
- Members: `alice`, `john`, and `rajat` are members  

---

## ðŸ“„ Fields of `/etc/gshadow`

The `/etc/gshadow` file stores encrypted group passwords and group administrators.

### ðŸ”¹ View gshadow file (root only):
```bash
sudo cat /etc/gshadow
```

**Output:**
```
root:::
sudo:*::rajat,alice
docker:!::rajat,bob
developers:!::alice,john
```

---

### ðŸ”¹ Gshadow File Format
```
groupname:password:administrators:members
```

---

### ðŸ”¹ Understanding Each Field

| Field | Position | Meaning | Example |
|-------|----------|---------|---------|
| Group Name | 1 | Name of group | `developers` |
| Password | 2 | Encrypted group password | `!` or `*` |
| Administrators | 3 | Who can manage group | `alice,john` |
| Members | 4 | Group members (secondary) | `rajat,bob` |

---

### ðŸ”¸ Password Symbols in gshadow

| Symbol | Meaning |
|--------|---------|
| `*` | No group password set |
| `!` | Group password locked |
| `$6$...` | Encrypted password (SHA-512) |
| (blank) | No password set |

---

## ðŸŽ¯ Types of Groups

### ðŸ”¹ 1. Primary Group
- Automatically created when user is created  
- User's primary group (found in `/etc/passwd`)  
- Has same name as username  
- One user = one primary group  

#### ðŸ”¸ Example:
```bash
cat /etc/passwd | grep rajat
```
**Output:**
```
rajat:x:1000:1000:Rajat Kumar:/home/rajat:/bin/bash
```
**Meaning:** GID 1000 is rajat's primary group

---

### ðŸ”¹ 2. Secondary Groups
- Additional groups a user belongs to  
- Provides extra permissions  
- Can be shared among users  
- One user = multiple secondary groups  

#### ðŸ”¸ Example:
```bash
groups rajat
```
**Output:**
```
rajat docker sudo developers
```
**Meaning:** 
- Primary: `rajat`  
- Secondary: `docker`, `sudo`, `developers`  

---

### ðŸ”¹ 3. System Groups
- GID: 0-999  
- Used for system services  
- Examples: `root`, `bin`, `daemon`, `www-data`  

#### ðŸ”¸ View system groups:
```bash
cat /etc/group | head -20
```

---

## âž• Creating and Deleting Groups

### ðŸ”¹ Creating Groups

#### Syntax:
```bash
sudo groupadd [options] groupname
```

---

### ðŸ”¸ Example 1: Create a simple group
```bash
sudo groupadd developers
```
**What happens?**
- Group `developers` created with auto-assigned GID  

---

### ðŸ”¸ Example 2: Create group with specific GID
```bash
sudo groupadd -g 2000 devops_team
```
**What happens?**
- Group created with GID 2000  

---

### ðŸ”¸ Example 3: Create system group
```bash
sudo groupadd -r ci_system
```
**What happens?**
- Group created with system GID range (1-999)  

---

### ðŸ”¹ Deleting Groups

#### Syntax:
```bash
sudo groupdel groupname
```

---

### ðŸ”¸ Example 1: Delete a group
```bash
sudo groupdel developers
```
**What happens?**
- Group `developers` is deleted  
- Error if group is primary group of any user  

---

### ðŸ”¸ Example 2: Delete group and reassign users
```bash
# First remove users from group or change their primary group
sudo usermod -g other_group username

# Then delete group
sudo groupdel developers
```

---

## ðŸ”§ Modifying Groups

### ðŸ”¹ Using `groupmod` Command

#### Syntax:
```bash
sudo groupmod [options] groupname
```

---

### ðŸ”¸ Example 1: Change group name
```bash
sudo groupmod -n new_name old_name
```
**What happens?**
- Group `old_name` renamed to `new_name`  

#### ðŸ”¸ Example:
```bash
sudo groupmod -n backend developers
```

---

### ðŸ”¸ Example 2: Change group GID
```bash
sudo groupmod -g 3000 developers
```
**What happens?**
- Group `developers` GID changed to 3000  
- Files still belong to old GID (needs manual fix)  

---

### ðŸ”¸ Example 3: Change group password
```bash
sudo groupmod -p encrypted_password developers
```

---

## ðŸ‘¥ Managing Group Memberships

### ðŸ”¹ Adding Users to Groups

#### Syntax:
```bash
sudo usermod -aG groupname username
```

**Flag Meaning:**
- `-a` = Append (add to existing groups)  
- `-G` = Groups (specify additional groups)  
- âš ï¸ Without `-a`, user is REMOVED from other groups!  

---

### ðŸ”¸ Example 1: Add user to docker group
```bash
sudo usermod -aG docker rajat
```
**What happens?**
- User `rajat` added to `docker` group  
- Retains all other group memberships  

---

### ðŸ”¸ Example 2: Add user to multiple groups
```bash
sudo usermod -aG docker,sudo,developers rajat
```
**What happens?**
- User `rajat` added to three groups at once  

---

### ðŸ”¸ Example 3: Replace all groups (without -a)
```bash
sudo usermod -G docker rajat
```
âš ï¸ **Warning!**
- User `rajat` REMOVED from all groups except `docker`  
- Can cause permission issues  
- Always use `-aG` instead!  

---

### ðŸ”¹ Removing Users from Groups

#### Syntax:
```bash
sudo delgroup username groupname
```

---

### ðŸ”¸ Example 1: Remove user from docker group
```bash
sudo delgroup rajat docker
```
**What happens?**
- User `rajat` removed from `docker` group  
- Other groups remain unchanged  

---

### ðŸ”¸ Example 2: Remove user from multiple groups
```bash
sudo delgroup rajat docker
sudo delgroup rajat sudo
sudo delgroup rajat developers
```

---

### ðŸ”¹ Verifying Group Membership

#### Check user's groups:
```bash
groups rajat
```
**Output:**
```
rajat : rajat docker developers sudo
```

---

#### Check group members:
```bash
getent group docker
```
**Output:**
```
docker:x:999:rajat,bob,alice
```

---

## ðŸ” Viewing and Editing Group Information

### ðŸ”¹ Viewing Group Details

#### All groups on system:
```bash
cat /etc/group
```

---

#### Specific group info:
```bash
getent group developers
```
**Output:**
```
developers:x:1001:alice,john,rajat
```

---

#### All groups for a user:
```bash
groups rajat
```

---

#### Group ID of a user's primary group:
```bash
id rajat
```
**Output:**
```
uid=1000(rajat) gid=1000(rajat) groups=1000(rajat),999(docker),27(sudo),1001(developers)
```

---

### ðŸ”¹ Editing Group Information Safely

âš ï¸ **Never edit `/etc/group` or `/etc/gshadow` directly!**  
Use proper commands instead:

#### âœ… Correct Way:
```bash
sudo usermod -aG docker rajat
sudo groupmod -n newname oldname
sudo groupdel groupname
```

#### âŒ Wrong Way:
```bash
sudo nano /etc/group          # Don't do this!
sudo vi /etc/gshadow          # Don't do this!
```

---

### ðŸ”¹ Checking Group Syntax

If you must edit manually, validate syntax:
```bash
sudo grpck
```
**Output:**
```
(no errors or errors listed)
```

---

## â­ Real-World DevOps Scenarios

### ðŸ”¸ Scenario 1: Onboard new DevOps engineer
```bash
# Create user
sudo useradd -m -s /bin/bash -c "Bob Engineer" bob

# Set password
sudo passwd bob

# Add to required groups
sudo usermod -aG docker,sudo,developers bob

# Set strong password policy
sudo chage -M 90 -m 1 -W 14 -I 7 bob

# Verify setup
groups bob
id bob
```

---

### ðŸ”¸ Scenario 2: Create CI/CD deployment group
```bash
# Create group
sudo groupadd cicd_team

# Create deployment user
sudo useradd -m -s /bin/bash deployer

# Add user to group
sudo usermod -aG cicd_team deployer

# Set password policy (no expiration for automation)
sudo chage -E -1 deployer

# Verify
getent group cicd_team
```

---

### ðŸ”¸ Scenario 3: Enforce password policy company-wide
```bash
# Edit login.defs
sudo nano /etc/login.defs

# Change these values:
# PASS_MAX_DAYS   90
# PASS_MIN_DAYS   1
# PASS_WARN_AGE   14
# PASS_MIN_LEN    12

# Apply to existing users
for user in $(cut -d: -f1 /etc/passwd | grep -v root); do
  sudo chage -M 90 -m 1 -W 14 $user
done
```

---

### ðŸ”¸ Scenario 4: Audit user accounts and cleanup
```bash
# List all users with expiration dates
for user in $(cut -d: -f1 /etc/passwd); do
  sudo chage -l $user | grep "Account expires"
done

# Remove inactive user
sudo userdel -r old_contractor

# Ensure group cleanup
sudo groupdel unused_group
```

---

## ðŸŽ¯ Key Takeaways

âœ… Strong passwords are **foundation of security**  
âœ… Use `passwd -e` to force password change  
âœ… Use `passwd -l` to lock accounts  
âœ… Use `chage` for password expiration policies  
âœ… Always use `usermod -aG` (never omit `-a`)  
âœ… Primary group created automatically with user  
âœ… Secondary groups provide additional permissions  
âœ… Never edit `/etc/group` directly  
âœ… Use `groups` command to verify membership  
âœ… `getent` shows all groups on system  

---

## ðŸ“ Quick Reference: Password & Group Commands

```bash
# PASSWORD COMMANDS
passwd rajat                          # Change password
sudo passwd -e rajat                  # Force change on login
sudo passwd -l rajat                  # Lock account
sudo passwd -u rajat                  # Unlock account
sudo chage -l rajat                   # View password aging
sudo chage -M 90 rajat                # Max 90 days
sudo chage -E 2026-12-31 rajat        # Account expiration

# GROUP COMMANDS
sudo groupadd developers              # Create group
sudo groupadd -g 2000 devops          # With specific GID
sudo groupdel developers              # Delete group
sudo groupmod -n newname oldname      # Rename group
sudo groupmod -g 2000 developers      # Change GID

# MEMBERSHIP COMMANDS
sudo usermod -aG docker rajat         # Add to group
sudo usermod -aG docker,sudo rajat    # Add to multiple
sudo delgroup rajat docker            # Remove from group
groups rajat                          # View user's groups
getent group docker                   # View group members
id rajat                              # Full user/group info

# VIEWING COMMANDS
cat /etc/passwd                       # All users
cat /etc/group                        # All groups
sudo cat /etc/shadow                  # Password hashes
sudo cat /etc/gshadow                 # Group passwords
```

---

// ...existing code...

---

# ðŸ” File Permissions in Linux â€” Deep Explanation

## Importance of File Permissions
- Protects data confidentiality, integrity and availability.  
- Restricts who can read, modify, or execute files and directories.  
- Prevents accidental or malicious changes.  
- Essential for multi-user systems and services (security boundary).

---

## rwx: Read, Write, Execute (what they mean)
- r (read) â†’ For files: can view content. For directories: can list names.  
- w (write) â†’ For files: can modify or delete. For directories: can create/delete entries.  
- x (execute) â†’ For files: can execute as program/script. For directories: can enter (cd) and access inodes.

Permission groups: owner (user), group, others (world). Permissions are applied in this order.

---

## How Permissions Are Displayed (ls -l)
Run:
```bash
ls -l filename
```
Typical output:
```
-rw-r--r-- 1 rajat developers 1024 Dec 09 12:00 file.txt
```
Fields:
1. Permission string (10 chars)
2. Link count
3. Owner
4. Group
5. Size
6. Timestamp
7. Name

Permission string structure:
- First char = file type (e.g., '-' file, 'd' dir, 'l' symlink)  
- Next 9 chars = owner (rwx), group (rwx), others (rwx)

---

## Example: Breaking Down -rwxr-xr--
Permission string:
```
-rwxr-xr--
```
Breakdown:
- '-' â†’ regular file  
- Owner bits `rwx` â†’ owner can read, write, execute (7)  
- Group bits `r-x` â†’ group can read and execute, not write (5)  
- Others bits `r--` â†’ others can only read (4)

Numeric representation: 754 (7 owner + 5 group + 4 others).

---

## Numeric (octal) vs Symbolic Modes

Numeric (octal):
- r=4, w=2, x=1 â†’ sum per class.
- Example: `chmod 754 file` â†’ owner=rwx, group=r-x, others=r--.

Symbolic:
- `chmod u=rwx,g=rx,o=r file`  
- Append/remove: `chmod g+w file` (add write to group), `chmod o-x file` (remove execute for others).

Examples:
```bash
chmod 644 file.txt     # owner rw-, group r--, others r--
chmod 755 script.sh    # owner rwx, group rx, others rx (common for executables)
chmod u+x script.sh    # add execute for owner
chmod g-w file.txt     # remove write for group
```

---

## Special Permission Bits (setuid, setgid, sticky)
- setuid (s in owner execute position): file runs with owner's privileges. Numeric: 4xxx.
  - Example: `chmod 4755 /usr/bin/someprog`
- setgid (s in group execute position): file runs with group privileges or directory files created inherit group. Numeric: 2xxx.
  - Example: `chmod 2755 /opt/shared`
- sticky bit (t in others execute position): on directories, only owner of file/dir or root can delete entries. Numeric: 1xxx.
  - Example: `/tmp` usually has `drwxrwxrwt` and `chmod 1777 /tmp`.

Numeric example with special bits:
```bash
chmod 1755 public_dir    # sticky + rwxr-xr-x
chmod 2775 team_dir      # setgid + rwxrwxr-x (new files inherit group)
chmod 4755 su_prog       # setuid + rwxr-xr-x
```

---

## File Types (first char in ls -l)
Symbols and meanings:
- - : regular file  
- d : directory  
- l : symbolic link  
- b : block device (e.g., /dev/sda)  
- c : character device (e.g., /dev/tty)  
- s : socket (IPC, network communication)  
- p : FIFO / named pipe

Examples:
```bash
-rw-r--r--   regular file
drwxr-xr-x   directory
lrwxrwxrwx   symlink -> target
brw-rw----   block device (usually in /dev)
crw-rw----   character device
srwxrwxrwx   socket
prw-r--r--   named pipe (FIFO)
```

---

// ...existing code...

---

# Day-12 âœ… Managing Users and Permissions in Linux

## Link Count Basics
- Link count (second column after permissions in ls -l) shows how many directory entries point to the same inode.
- For files: link count = number of hard links to that file (default 1).
- For directories: link count = number of subdirectories + 2 (for "." and "..").

Example:
```bash
ls -l file.txt
# -rw-r--r-- 2 rajat users 1024 Dec 10 12:00 file.txt   # link count = 2 (two hard links)
```

## Link Count for Directories
- A directory's link count increases by 1 when a new subdirectory is created inside it.
- Example:
```bash
mkdir project
ls -ld project        # drwxr-xr-x 2 rajat users ...
mkdir project/src
ls -ld project        # drwxr-xr-x 3 rajat users ...  (now 3: ".", "..", "src")
```

## Link Count for Files
- Creating a hard link increments the file's link count.
- Remove a hard link with rm â€” file data removed only when link count reaches 0.
```bash
echo hello > a.txt
ln a.txt b.txt
ls -l a.txt b.txt
# both show link count 2
rm a.txt
ls -l b.txt           # still accessible, link count 1
```

## Comparing Hard and Soft (Symbolic) Links
- Hard link:
  - Shares same inode and data as original file.
  - Cannot cross filesystem boundaries.
  - Cannot link to directories (without special privileges).
  - Created with: ln target linkname
- Soft (symbolic) link:
  - Special file that points to target path.
  - Can point across filesystems and to directories.
  - If target removed, symlink becomes dangling.
  - Created with: ln -s target linkname

Examples:
```bash
# Hard link
ln file.txt file_hard
stat file.txt file_hard   # same inode number

# Symbolic link
ln -s /etc/nginx/nginx.conf nginx.conf.symlink
ls -l nginx.conf.symlink  # shows -> /etc/nginx/nginx.conf
readlink -f nginx.conf.symlink  # resolves target
```

## Importance of sudo for Privilege Escalation
- sudo allows a permitted user to run commands as root or another user without logging in as that user.
- Benefits:
  - Avoids sharing root password.
  - Fine-grained access control and auditing (sudo logs).
  - Reduces time spent in a full root shell, minimizing accidental damage.

## Difference Between Regular User Commands and sudo Commands
- Regular user:
  - Runs with user's UID/GID and permissions.
  - Cannot modify files owned by root or perform privileged ops.
- Using sudo:
  - Command executes with elevated privileges (usually root).
  - Prompts for user's password (not root) by default.
  - Environment may differ (use sudo -i or sudo -H to get a root-like env).
  - sudo logs commands to syslog/journal for audit.

Examples:
```bash
# regular user cannot edit /etc/hosts
nano /etc/hosts        # permission denied

# with sudo
sudo nano /etc/hosts  # allowed if user in sudoers
```

## Configuring sudo Access
- Always edit sudoers via visudo to avoid syntax errors:
```bash
sudo visudo
```
- Add a user to sudo group (Debian/Ubuntu):
```bash
sudo usermod -aG sudo rajat
```
- Example sudoers entries:
```text
# Allow rajat to run any command as any user
rajat ALL=(ALL) ALL

# Allow user to run specific commands without password
rajat ALL=(ALL) NOPASSWD: /usr/bin/systemctl, /usr/bin/restart-service
```
- Use group-based rules:
```text
%devops ALL=(ALL) ALL  # members of devops group have full sudo
```

## sudo Command Syntax and Examples
- Basic:
```bash
sudo <command>
```
- Run a command as another user:
```bash
sudo -u otheruser <command>
```
- Get an interactive root shell (preserves login environment):
```bash
sudo -i
```
- Preserve environment variables:
```bash
sudo -E <command>
```

Practical examples:
```bash
sudo apt update                      # run package update as root
sudo systemctl restart nginx         # restart service with elevated rights
sudo -u postgres psql -c "\l"        # run psql as postgres user
sudo visudo                           # safely edit sudoers
```

---

## Quick Troubleshooting Tips
- If sudo reports "user is not in the sudoers file", add the user to sudoers via a root account or a user who already has sudo.
- Use sudo -l to list allowed commands for current user:
```bash
sudo -l
```
- Always validate sudoers syntax with visudo; wrong syntax can lock out sudo access.

---

// ...existing code...

---

# Day-13 âœ… Automation and Data Handling in Linux

## Overview of Archiving

Archiving is the process of combining multiple files and directories into a single file (archive) for easier storage, transfer, and management.  
Archives help in organizing data, reducing clutter, and preparing files for backup or distribution.

### ðŸ”¹ Why Archive Files?
- **Consolidation**: Multiple files â†’ single archive file  
- **Organization**: Group related files together  
- **Transfer**: Easier to send one file instead of many  
- **Backup**: Create snapshots of data  
- **Space Management**: Prepare for compression  

### ðŸ”¹ Common Archive Formats
- **tar**: Tape Archive (most common in Linux)  
- **zip**: Cross-platform (Windows/Linux/Mac)  
- **rar**: Proprietary (less common in Linux)  

---

## Common Use Cases: Backups, Data Transfer, Organization

### ðŸ”¹ 1. Backups
- Archive entire directories before system updates  
- Create weekly backups of user data  
- Store archives on external drives or cloud  

### ðŸ”¹ 2. Data Transfer
- Bundle project files for sharing  
- Send large datasets over network  
- Upload archives to servers  

### ðŸ”¹ 3. Organization
- Group log files by date  
- Archive old projects  
- Clean up scattered files  

---

## Creating and Extracting Archives with tar

`tar` is the standard archiving tool in Linux. It doesn't compress by default â€” just bundles files.

### ðŸ”¹ Basic Syntax
```bash
tar [options] archive-name.tar files/directories
```

### ðŸ”¹ Common Options
- `-c` â†’ Create archive  
- `-x` â†’ Extract archive  
- `-v` â†’ Verbose (show progress)  
- `-f` â†’ Specify filename  
- `-t` â†’ List archive contents  
- `-r` â†’ Append files to archive  
- `-C` â†’ Change to directory  

---

### ðŸ”¸ Creating Archives

#### Example 1: Create simple archive
```bash
tar -cvf myfiles.tar file1.txt file2.txt folder/
```
**What happens?**
- Creates `myfiles.tar` containing specified files  
- `-c` create, `-v` verbose, `-f` filename  

#### Example 2: Archive entire directory
```bash
tar -cvf backup.tar /home/user/documents/
```
**What happens?**
- Archives the entire documents directory  

#### Example 3: Archive with absolute paths
```bash
tar -cvf full-backup.tar /etc /var/log
```
**What happens?**
- Includes full paths in archive  

---

### ðŸ”¸ Extracting Archives

#### Example 1: Extract to current directory
```bash
tar -xvf myfiles.tar
```
**What happens?**
- Extracts all files to current location  

#### Example 2: Extract to specific directory
```bash
tar -xvf backup.tar -C /tmp/restore/
```
**What happens?**
- Extracts to `/tmp/restore/` directory  

#### Example 3: Extract specific files
```bash
tar -xvf archive.tar file1.txt folder/
```
**What happens?**
- Only extracts specified files/folders  

---

## Managing Archive Contents

### ðŸ”¹ Listing Archive Contents
```bash
tar -tvf archive.tar
```
**Output:**
```
-rw-r--r-- user/group    1024 2023-12-10 12:00 file1.txt
drwxr-xr-x user/group       0 2023-12-10 12:00 folder/
-rw-r--r-- user/group     512 2023-12-10 12:00 folder/file2.txt
```

### ðŸ”¹ Appending Files to Archive
```bash
tar -rvf archive.tar newfile.txt
```
**What happens?**
- Adds `newfile.txt` to existing archive  

### ðŸ”¹ Verifying Archive Integrity
```bash
tar -tvf archive.tar > /dev/null
```
**What happens?**
- Checks if archive is readable (no output if OK)  

---

## Introduction to Compression

Compression reduces file sizes by removing redundant data, making files smaller for storage and transfer.

### ðŸ”¹ Why Compress?
- **Save Storage Space**: Smaller files = more storage  
- **Faster Transfers**: Less data to send over network  
- **Backup Efficiency**: Compress before archiving  

### ðŸ”¹ Lossless vs Lossy Compression
- **Lossless**: No data loss (gzip, bzip2, xz)  
- **Lossy**: Some data loss for better compression (images, audio)  

---

## The Role of Compression in Reducing File Sizes

Compression algorithms identify patterns and replace them with shorter codes.

### ðŸ”¹ How It Works
- **Repetition**: "aaaaa" â†’ "5a"  
- **Patterns**: Common sequences replaced with symbols  
- **Dictionaries**: Build reference tables  

### ðŸ”¹ Compression Ratio
- Original: 1MB  
- Compressed: 300KB  
- Ratio: 70% reduction  

---

## Differences Between Compression Formats

| Format | Tool | Compression Ratio | Speed | Use Case |
|--------|------|-------------------|-------|----------|
| **gzip** | gzip/gunzip | Medium | Fast | General purpose |
| **bzip2** | bzip2/bunzip2 | High | Medium | Better compression |
| **xz** | xz/unxz | Highest | Slow | Maximum compression |

### ðŸ”¹ gzip (.gz)
- Fast compression/decompression  
- Good for text files  
- Used in HTTP compression  

### ðŸ”¹ bzip2 (.bz2)
- Better compression than gzip  
- Slower but smaller files  
- Good for large archives  

### ðŸ”¹ xz (.xz)
- Best compression ratio  
- Slowest but smallest files  
- Used for software packages  

---

## Using gzip and gunzip

### ðŸ”¹ Compressing Files
```bash
gzip file.txt
```
**Result:** `file.txt.gz` (original deleted)

### ðŸ”¹ Compressing with options
```bash
gzip -k file.txt    # Keep original file
gzip -9 file.txt    # Maximum compression
```

### ðŸ”¹ Decompressing Files
```bash
gunzip file.txt.gz
```
**Result:** `file.txt` (compressed deleted)

### ðŸ”¹ Decompress with options
```bash
gunzip -k file.txt.gz    # Keep compressed file
gunzip -c file.txt.gz > output.txt    # Decompress to stdout
```

---

## Using bzip2 and bunzip2

### ðŸ”¹ Compressing Files
```bash
bzip2 file.txt
```
**Result:** `file.txt.bz2`

### ðŸ”¹ Compressing with options
```bash
bzip2 -k file.txt    # Keep original
bzip2 -9 file.txt    # Maximum compression
```

### ðŸ”¹ Decompressing Files
```bash
bunzip2 file.txt.bz2
```
**Result:** `file.txt`

### ðŸ”¹ Decompress with options
```bash
bunzip2 -k file.txt.bz2    # Keep compressed
bunzip2 -c file.txt.bz2 > output.txt    # To stdout
```

---

## Using xz and unxz

### ðŸ”¹ Compressing Files
```bash
xz file.txt
```
**Result:** `file.txt.xz`

### ðŸ”¹ Compressing with options
```bash
xz -k file.txt    # Keep original
xz -9 file.txt    # Maximum compression
```

### ðŸ”¹ Decompressing Files
```bash
unxz file.txt.xz
```
**Result:** `file.txt`

### ðŸ”¹ Decompress with options
```bash
unxz -k file.txt.xz    # Keep compressed
unxz -c file.txt.xz > output.txt    # To stdout
```

---

## Combining Archiving and Compression

`tar` can compress archives on the fly using options.

### ðŸ”¹ tar with gzip
```bash
tar -czvf archive.tar.gz files/    # Create compressed archive
tar -xzvf archive.tar.gz           # Extract compressed archive
```

### ðŸ”¹ tar with bzip2
```bash
tar -cjvf archive.tar.bz2 files/   # Create
tar -xjvf archive.tar.bz2          # Extract
```

### ðŸ”¹ tar with xz
```bash
tar -cJvf archive.tar.xz files/    # Create
tar -xJvf archive.tar.xz           # Extract
```

### ðŸ”¹ Compression Options Summary
- `-z` â†’ gzip  
- `-j` â†’ bzip2  
- `-J` â†’ xz  

---

## Practical: Compressing Files with tar, gzip, bzip2, xz

### ðŸ”¸ Example 1: Compress directory with tar + gzip
```bash
tar -czvf project-backup.tar.gz /home/user/project/
```
**Result:** Single compressed file

### ðŸ”¸ Example 2: Compress logs with tar + bzip2
```bash
tar -cjvf logs-backup.tar.bz2 /var/log/
```
**Result:** Smaller archive than gzip

### ðŸ”¸ Example 3: Compress software with tar + xz
```bash
tar -cJvf software.tar.xz /opt/myapp/
```
**Result:** Maximum compression

### ðŸ”¸ Example 4: Compress single file with gzip
```bash
gzip -k large-file.txt
```
**Result:** `large-file.txt.gz` + original kept

### ðŸ”¸ Example 5: Compress multiple files with bzip2
```bash
bzip2 file1.txt file2.txt file3.txt
```
**Result:** `file1.txt.bz2`, `file2.txt.bz2`, `file3.txt.bz2`

---

## Practical: Decompressing Files with tar, gunzip, bunzip2, unxz

### ðŸ”¸ Example 1: Extract tar.gz archive
```bash
tar -xzvf project-backup.tar.gz -C /tmp/
```
**Result:** Files extracted to `/tmp/`

### ðŸ”¸ Example 2: Extract tar.bz2 archive
```bash
tar -xjvf logs-backup.tar.bz2
```
**Result:** Logs extracted to current directory

### ðŸ”¸ Example 3: Extract tar.xz archive
```bash
tar -xJvf software.tar.xz -C /opt/
```
**Result:** Software extracted to `/opt/`

### ðŸ”¸ Example 4: Decompress gzip file
```bash
gunzip large-file.txt.gz
```
**Result:** `large-file.txt`

### ðŸ”¸ Example 5: Decompress bzip2 files
```bash
bunzip2 *.bz2
```
**Result:** All .bz2 files decompressed

---

## Introduction to CronTab

CronTab is a time-based job scheduler in Linux. It runs commands or scripts at specified times/dates automatically.

### ðŸ”¹ Why Use CronTab?
- **Automation**: Run tasks without manual intervention  
- **Scheduling**: Execute at specific times  
- **Maintenance**: Regular backups, updates, cleanup  

### ðŸ”¹ CronTab Components
- **Cron Daemon**: `crond` service that runs in background  
- **CronTab File**: User-specific schedule file  
- **System CronTab**: `/etc/crontab` for system-wide jobs  

---

## Understanding The CronTab Syntax

CronTab entries have 6 fields: minute, hour, day, month, weekday, command.

### ðŸ”¹ Syntax Format
```
* * * * * command
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â””â”€ Day of week (0-7, 0=Sunday)
â”‚ â”‚ â”‚ â””â”€â”€â”€ Month (1-12)
â”‚ â”‚ â””â”€â”€â”€â”€â”€ Day of month (1-31)
â”‚ â””â”€â”€â”€â”€â”€â”€â”€ Hour (0-23)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ Minute (0-59)
```

### ðŸ”¹ Special Characters
- `*` â†’ Any value  
- `,` â†’ List (1,3,5)  
- `-` â†’ Range (1-5)  
- `/` â†’ Step (*/5 = every 5 units)  

### ðŸ”¹ Examples
- `0 2 * * *` â†’ Daily at 2:00 AM  
- `*/15 * * * *` â†’ Every 15 minutes  
- `0 9-17 * * 1-5` â†’ Weekdays 9 AM to 5 PM hourly  
- `0 0 1 * *` â†’ First day of every month  

---

## Creating and Managing Cron Jobs

### ðŸ”¹ Editing CronTab
```bash
crontab -e    # Edit current user's crontab
```

### ðŸ”¹ Viewing CronTab
```bash
crontab -l    # List current user's jobs
```

### ðŸ”¹ Removing CronTab
```bash
crontab -r    # Remove all jobs
```

### ðŸ”¹ Editing System CronTab
```bash
sudo nano /etc/crontab    # System-wide jobs
```

---

### ðŸ”¸ Creating Cron Jobs: Examples

#### Example 1: Daily backup at 2 AM
```bash
crontab -e
# Add this line:
0 2 * * * tar -czf /home/user/daily-backup.tar.gz /home/user/documents/
```

#### Example 2: Run script every hour
```bash
# In crontab:
0 * * * * /home/user/hourly-script.sh
```

#### Example 3: Weekly cleanup on Sundays
```bash
# In crontab:
0 3 * * 0 rm -rf /tmp/old-files/
```

#### Example 4: Monthly report on 1st
```bash
# In crontab:
0 6 1 * * /usr/local/bin/generate-report.sh
```

---

## Automating Routine Tasks like Backups, System Updates, and Cleanup Scripts

### ðŸ”¹ Automating Backups
```bash
# Daily database backup
0 2 * * * mysqldump -u root -p'password' mydb > /backup/db-$(date +\%Y\%m\%d).sql

# Weekly full backup
0 3 * * 0 tar -czf /backup/weekly-$(date +\%Y\%m\%d).tar.gz /home/
```

### ðŸ”¹ System Updates
```bash
# Daily security updates
0 4 * * * apt update && apt upgrade -y

# Reboot after kernel update (if needed)
0 5 * * * [ -f /var/run/reboot-required ] && reboot
```

### ðŸ”¹ Cleanup Scripts
```bash
# Clean temp files daily
0 1 * * * rm -rf /tmp/* /var/tmp/*

# Rotate logs weekly
0 2 * * 0 logrotate /etc/logrotate.conf

# Remove old backups (keep last 7)
0 3 * * * find /backup -name "*.tar.gz" -mtime +7 -delete
```

---

## â­ Real-World DevOps Scenarios

### ðŸ”¸ Scenario 1: Automated Website Backup
```bash
# Backup web files and database daily
0 2 * * * tar -czf /backup/web-$(date +\%Y\%m\%d).tar.gz /var/www/
0 2 * * * mysqldump wordpress > /backup/db-$(date +\%Y\%m\%d).sql
```

### ðŸ”¸ Scenario 2: Log Rotation and Cleanup
```bash
# Rotate nginx logs daily
0 0 * * * logrotate /etc/logrotate.d/nginx

# Clean old logs weekly
0 1 * * 0 find /var/log -name "*.gz" -mtime +30 -delete
```

### ðŸ”¸ Scenario 3: System Health Monitoring
```bash
# Check disk space hourly
0 * * * * df -h | grep -E "9[0-9]%|100%" | mail -s "Disk Space Alert" admin@example.com

# Restart service if down
*/5 * * * * systemctl is-active --quiet nginx || systemctl restart nginx
```

### ðŸ”¸ Scenario 4: CI/CD Pipeline Trigger
```bash
# Poll for changes every 5 minutes
*/5 * * * * cd /repo && git pull && ./build.sh
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Archiving** bundles files for organization and transfer  
âœ… **tar** creates archives, combine with `-z/-j/-J` for compression  
âœ… **gzip** fast, **bzip2** better compression, **xz** best compression  
âœ… **CronTab** automates tasks with time-based scheduling  
âœ… Use `crontab -e` to edit, `crontab -l` to list jobs  
âœ… Test cron jobs manually before scheduling  
âœ… Always use absolute paths in cron commands  

---

## ðŸ“ Quick Reference: Archiving, Compression & Cron Commands

```bash
# ARCHIVING WITH TAR
tar -cvf archive.tar files/          # Create archive
tar -xvf archive.tar                 # Extract archive
tar -tvf archive.tar                 # List contents
tar -rvf archive.tar newfile         # Append to archive

# COMPRESSION
gzip file.txt                        # Compress to .gz
gunzip file.txt.gz                   # Decompress .gz
bzip2 file.txt                       # Compress to .bz2
bunzip2 file.txt.bz2                 # Decompress .bz2
xz file.txt                          # Compress to .xz
unxz file.txt.xz                     # Decompress .xz

# TAR + COMPRESSION
tar -czvf archive.tar.gz files/      # gzip
tar -cjvf archive.tar.bz2 files/     # bzip2
tar -cJvf archive.tar.xz files/      # xz
tar -xzvf archive.tar.gz             # extract gzip
tar -xjvf archive.tar.bz2            # extract bzip2
tar -xJvf archive.tar.xz             # extract xz

# CRONTAB
crontab -e                           # Edit crontab
crontab -l                           # List jobs
crontab -r                           # Remove all jobs
sudo crontab -e                      # Edit root crontab

# CRON SYNTAX EXAMPLES
* * * * * command                    # Every minute
0 * * * * command                    # Every hour
0 2 * * * command                    # Daily 2 AM
0 0 * * 0 command                    # Weekly Sunday midnight
0 0 1 * * command                    # Monthly 1st
```

---

## ðŸš¨ Common Issues & Troubleshooting

### ðŸ”¹ Cron Job Not Running
- Check `crontab -l` for syntax errors  
- Use absolute paths in commands  
- Check `/var/log/cron` or `journalctl -u cron` for errors  
- Test command manually first  

### ðŸ”¹ Archive Extraction Issues
- Use correct extraction flags (`-xzf` for .tar.gz)  
- Check permissions on target directory  
- Ensure enough disk space  

### ðŸ”¹ Compression Problems
- `gzip` can't compress already compressed files well  
- Use `file` command to check file types  
- Check available memory for large files  

---

## ðŸ“š Further Reading
- `man tar`, `man gzip`, `man crontab`  
- Cron expression generators online  
- Linux backup best practices  

---

// ...existing code...

---

# Day-15 âœ… Automation and Data Handling in Linux

## Introduction to Search and Filter Utilities

Search and filter utilities are essential tools in Linux for processing and analyzing text data.  
They allow DevOps engineers to efficiently locate, manipulate, and extract information from files and command outputs.

### ðŸ”¹ What Are Search and Filter Utilities?
- **Search**: Find specific patterns or content within files  
- **Filter**: Extract, sort, or modify data streams  
- **Process**: Handle large datasets and log files  
- **Automate**: Combine with scripts for data processing  

### ðŸ”¹ Common Use Cases
- Analyzing log files for errors  
- Extracting specific data from reports  
- Finding configuration issues  
- Processing large datasets  
- Automating data cleanup tasks  

---

## Importance of Searching and Filtering Data in Linux

In DevOps environments, searching and filtering is critical for:

### ðŸ”¹ System Administration
- **Log Analysis**: Quickly identify errors in system logs  
- **Configuration Management**: Find specific settings across files  
- **Troubleshooting**: Locate problematic processes or files  

### ðŸ”¹ Data Processing
- **Report Generation**: Extract relevant data from large files  
- **Data Cleaning**: Remove duplicates and sort information  
- **Automation**: Build scripts that process data automatically  

### ðŸ”¹ Security and Compliance
- **Audit Logs**: Search for security events  
- **Access Control**: Find unauthorized access attempts  
- **Compliance Checks**: Filter data for regulatory requirements  

### ðŸ”¹ Performance Benefits
- **Efficiency**: Process large files without loading everything into memory  
- **Speed**: Use pipes to chain commands for faster processing  
- **Scalability**: Handle growing data volumes in production systems  

---

## Overview of Key Utilities: grep, cat, sort, uniq

### ðŸ”¹ grep
- **Purpose**: Search for patterns in files or input streams  
- **Key Features**: Regular expressions, case-insensitive search, line numbers  
- **Use Case**: Find specific text in logs or code files  

### ðŸ”¹ cat
- **Purpose**: Concatenate and display file contents  
- **Key Features**: Display files, combine multiple files, show line numbers  
- **Use Case**: View file contents, create new files from input  

### ðŸ”¹ sort
- **Purpose**: Sort lines of text files or input streams  
- **Key Features**: Alphabetical/numerical sorting, reverse order, unique sorting  
- **Use Case**: Organize data, remove duplicates, prepare reports  

### ðŸ”¹ uniq
- **Purpose**: Remove duplicate lines from sorted input  
- **Key Features**: Show only unique lines, count occurrences, compare adjacent lines  
- **Use Case**: Clean data, identify duplicates, generate summaries  

### ðŸ”¹ Comparison Table

| Utility | Primary Function | Input Type | Output Type | Common Options |
|---------|------------------|------------|-------------|----------------|
| **grep** | Search patterns | Files/streams | Matching lines | `-i`, `-n`, `-v` |
| **cat** | Display/concatenate | Files | Combined output | `-n`, `-b`, `-s` |
| **sort** | Sort lines | Files/streams | Sorted output | `-r`, `-n`, `-k` |
| **uniq** | Remove duplicates | Sorted input | Unique lines | `-c`, `-d`, `-u` |

---

## Read Files Using cat, uniq, and sort

These utilities work together to read, process, and organize file contents.

### ðŸ”¹ Using cat to Read Files

#### Basic file reading:
```bash
cat file.txt
```
**Output:** Displays entire file content

#### Read multiple files:
```bash
cat file1.txt file2.txt
```
**Output:** Concatenates both files

#### Show line numbers:
```bash
cat -n file.txt
```
**Output:**
```
     1  First line
     2  Second line
     3  Third line
```

#### Suppress empty lines:
```bash
cat -s file.txt
```

---

### ðŸ”¹ Using sort to Organize Content

#### Basic alphabetical sort:
```bash
sort file.txt
```
**Output:** Lines sorted A-Z

#### Numerical sort:
```bash
sort -n numbers.txt
```
**Input:**
```
10
2
1
```
**Output:**
```
1
2
10
```

#### Reverse sort:
```bash
sort -r file.txt
```
**Output:** Z-A order

#### Sort by specific column:
```bash
sort -k 2 file.txt
```
**Sorts by second field (space/tab separated)**

#### Sort and remove duplicates:
```bash
sort -u file.txt
```
**Equivalent to `sort file.txt | uniq`**

---

### ðŸ”¹ Using uniq to Remove Duplicates

**Note:** `uniq` requires sorted input to work properly.

#### Remove duplicate lines:
```bash
sort file.txt | uniq
```
**Input:**
```
apple
banana
apple
cherry
```
**Output:**
```
apple
banana
cherry
```

#### Count occurrences:
```bash
sort file.txt | uniq -c
```
**Output:**
```
      2 apple
      1 banana
      1 cherry
```

#### Show only duplicates:
```bash
sort file.txt | uniq -d
```
**Output:**
```
apple
```

#### Show only unique lines:
```bash
sort file.txt | uniq -u
```
**Output:**
```
banana
cherry
```

---

### ðŸ”¹ Combining cat, sort, and uniq

#### Process a file: sort and remove duplicates
```bash
cat data.txt | sort | uniq
```

#### Count unique items in a file
```bash
cat names.txt | sort | uniq -c | sort -nr
```
**Output:** Most frequent names first

#### Find duplicate entries
```bash
cat log.txt | sort | uniq -d
```

---

## Introduction to the find Utility

`find` is a powerful command-line utility for searching files and directories based on various criteria.

### ðŸ”¹ Why Use find?
- **Locate Files**: Search by name, type, size, date, permissions  
- **Batch Operations**: Execute commands on found files  
- **System Administration**: Find old files, large files, specific types  
- **Automation**: Use in scripts for file management  

### ðŸ”¹ find vs Other Search Tools
- **locate**: Fast database search (requires updatedb)  
- **which**: Find executable files in PATH  
- **whereis**: Find binaries, sources, manuals  
- **find**: Comprehensive search with full control  

---

## Basic Syntax of find

### ðŸ”¹ Syntax Structure
```bash
find [path] [expression]
```

- **path**: Starting directory (default: current directory)  
- **expression**: Search criteria and actions  

### ðŸ”¹ Basic Examples

#### Find all files in current directory:
```bash
find .
```
**Output:** Lists all files and subdirectories recursively

#### Find files in specific directory:
```bash
find /home/user
```

#### Find files with specific name:
```bash
find . -name "file.txt"
```
**Output:** `./file.txt` (if found)

#### Case-insensitive name search:
```bash
find . -iname "FILE.txt"
```

---

## Advanced Usage and Filtering Options

### ðŸ”¹ Filtering by Type
```bash
find . -type f    # Files only
find . -type d    # Directories only
find . -type l    # Symbolic links only
```

### ðŸ”¹ Filtering by Name Patterns
```bash
find . -name "*.txt"        # Exact match
find . -iname "*.TXT"       # Case-insensitive
find . -name "*report*"     # Contains "report"
```

### ðŸ”¹ Filtering by Size
```bash
find . -size +100M          # Larger than 100MB
find . -size -1k            # Smaller than 1KB
find . -size 10M            # Exactly 10MB
```

### ðŸ”¹ Filtering by Time
```bash
find . -mtime -7            # Modified in last 7 days
find . -mtime +30           # Modified more than 30 days ago
find . -mtime 7             # Modified exactly 7 days ago
```

**Time Options:**
- `-mtime`: Modified time (days)  
- `-atime`: Access time  
- `-ctime`: Change time  

### ðŸ”¹ Filtering by Permissions
```bash
find . -perm 755            # Exact permissions
find . -perm -4000          # Has setuid bit
find . -perm /111           # Executable by someone
```

### ðŸ”¹ Combining Filters with Operators
```bash
find . -name "*.log" -mtime -7    # AND (both conditions)
find . -name "*.tmp" -o -name "*.bak"    # OR
find . -not -name "*.txt"        # NOT
```

### ðŸ”¹ Limiting Depth
```bash
find . -maxdepth 2 -name "*.txt"    # Search only 2 levels deep
find . -mindepth 1 -type f          # Skip current directory
```

---

## Practical Examples of Finding Files by Name, Type, Size, and Modification Date

### ðŸ”¹ By Name

#### Find all .txt files:
```bash
find /home -name "*.txt"
```

#### Find files starting with "config":
```bash
find . -name "config*"
```

#### Find files with case-insensitive extension:
```bash
find . -iname "*.JPG"
```

#### Find files containing "backup" in name:
```bash
find . -name "*backup*"
```

---

### ðŸ”¹ By Type

#### Find all regular files:
```bash
find . -type f
```

#### Find all directories:
```bash
find . -type d
```

#### Find all symbolic links:
```bash
find . -type l
```

#### Find all executable files:
```bash
find . -type f -executable
```

---

### ðŸ”¹ By Size

#### Find files larger than 1GB:
```bash
find . -type f -size +1G
```

#### Find files smaller than 100KB:
```bash
find . -type f -size -100k
```

#### Find files exactly 1MB:
```bash
find . -type f -size 1M
```

#### Find largest files in directory:
```bash
find . -type f -exec ls -lh {} \; | sort -k5 -hr | head -10
```

---

### ðŸ”¹ By Modification Date

#### Find files modified in last 24 hours:
```bash
find . -type f -mtime -1
```

#### Find files modified more than 30 days ago:
```bash
find . -type f -mtime +30
```

#### Find files modified between 7-14 days ago:
```bash
find . -type f -mtime +7 -mtime -14
```

#### Find files accessed in last hour:
```bash
find . -type f -amin -60
```

#### Find recently modified config files:
```bash
find /etc -name "*.conf" -mtime -7
```

---

### ðŸ”¹ Advanced Practical Examples

#### Find and delete old log files:
```bash
find /var/log -name "*.log" -mtime +30 -delete
```

#### Find large files and get their sizes:
```bash
find . -type f -size +100M -exec ls -lh {} \;
```

#### Find files owned by specific user:
```bash
find . -user rajat
```

#### Find files with specific permissions:
```bash
find . -perm 644
```

#### Find empty files and directories:
```bash
find . -empty
```

#### Find and compress old files:
```bash
find . -type f -mtime +365 -exec gzip {} \;
```

---

## â­ Real-World DevOps Scenarios

### ðŸ”¸ Scenario 1: Log Analysis
```bash
# Find error logs from last 24 hours
find /var/log -name "*.log" -mtime -1 -exec grep -l "ERROR" {} \;

# Count errors by type
find /var/log -name "*.log" -exec grep "ERROR" {} \; | sort | uniq -c
```

### ðŸ”¸ Scenario 2: Disk Cleanup
```bash
# Find large temporary files
find /tmp -type f -size +100M

# Remove old cache files
find ~/.cache -type f -mtime +30 -delete

# Archive old logs
find /var/log -name "*.log" -mtime +7 -exec tar -czf {}.tar.gz {} \; -exec rm {} \;
```

### ðŸ”¸ Scenario 3: Code Quality Check
```bash
# Find Python files with syntax errors
find . -name "*.py" -exec python -m py_compile {} \; 2>&1 | grep -v "SyntaxError"

# Find large source files
find . -name "*.py" -size +1M
```

### ðŸ”¸ Scenario 4: Security Audit
```bash
# Find world-writable files
find /home -type f -perm -002

# Find files modified recently (potential compromise)
find /etc -type f -mtime -1

# Find executable files in user directories
find /home -type f -executable
```

---

## ðŸŽ¯ Key Takeaways

âœ… **grep** searches for patterns in text  
âœ… **cat** displays and concatenates files  
âœ… **sort** organizes lines alphabetically/numerically  
âœ… **uniq** removes duplicates from sorted input  
âœ… **find** locates files by name, type, size, date, permissions  
âœ… Combine utilities with pipes for powerful data processing  
âœ… Use `-exec` with find to perform actions on found files  
âœ… Always test find commands before using `-delete`  

---

## ðŸ“ Quick Reference: Search and Filter Commands

```bash
# GREP - Search Patterns
grep "pattern" file.txt              # Basic search
grep -i "pattern" file.txt           # Case-insensitive
grep -n "pattern" file.txt           # Show line numbers
grep -v "pattern" file.txt           # Invert match
grep -r "pattern" /path/             # Recursive search

# CAT - Display Files
cat file.txt                         # Display file
cat -n file.txt                      # With line numbers
cat file1.txt file2.txt > combined.txt  # Concatenate

# SORT - Sort Lines
sort file.txt                        # Alphabetical sort
sort -n numbers.txt                  # Numerical sort
sort -r file.txt                     # Reverse sort
sort -k 2 file.txt                   # Sort by column 2
sort -u file.txt                     # Unique sort

# UNIQ - Remove Duplicates
uniq file.txt                        # Remove duplicates
uniq -c file.txt                     # Count occurrences
uniq -d file.txt                     # Show duplicates only
uniq -u file.txt                     # Show unique only

# FIND - Locate Files
find . -name "*.txt"                 # By name
find . -type f                       # Files only
find . -type d                       # Directories only
find . -size +1M                     # Larger than 1MB
find . -mtime -7                     # Modified last 7 days
find . -perm 755                     # Specific permissions
find . -exec ls -l {} \;             # Execute command on results
```

---

## ðŸš¨ Common Issues & Troubleshooting

### ðŸ”¹ find Not Finding Files
- Check permissions on directories  
- Use absolute paths  
- Verify file actually exists  

### ðŸ”¹ grep No Results
- Check case sensitivity (`-i` flag)  
- Use word boundaries (`\<word\>`)  
- Check if file has content  

### ðŸ”¹ sort Not Working as Expected
- Use `-n` for numerical sorting  
- Specify key with `-k` for column sorting  
- Check locale settings  

### ðŸ”¹ uniq Not Removing Duplicates
- Input must be sorted first  
- Use `sort | uniq`  

---

## ðŸ“š Further Reading
- `man grep`, `man find`, `man sort`  
- Regular expressions guide  
- Advanced find command tutorials  

// ...existing code...

---

# Day-16 âœ… Managing Processes and Optimizing Performance

## Introduction to Processes

A **process** is a running instance of a program in Linux. Every time you run a command or application, it creates one or more processes.

### ðŸ”¹ What is a Process?
- **Program in Execution**: Code + data + resources  
- **Independent Entity**: Each process has its own memory space  
- **Managed by Kernel**: OS schedules and controls processes  
- **Has Unique ID**: Process ID (PID) identifies each process  

### ðŸ”¹ Why Manage Processes?
- **Resource Allocation**: CPU, memory, I/O  
- **System Stability**: Prevent runaway processes  
- **Performance Monitoring**: Identify bottlenecks  
- **Troubleshooting**: Debug hanging applications  
- **Automation**: Control background tasks  

### ðŸ”¹ Process Lifecycle
1. **Creation**: Fork from parent process  
2. **Execution**: Running state  
3. **Termination**: Normal exit or kill  
4. **Cleanup**: Resources freed by kernel  

---

## Types of Processes and Jobs

### ðŸ”¹ Types of Processes

#### 1. **Foreground Processes**
- **Interactive**: Run in terminal, user waits for completion  
- **Examples**: `ls`, `nano`, `gcc compile.c`  
- **Control**: User can interrupt with Ctrl+C  

#### 2. **Background Processes**
- **Non-Interactive**: Run independently of terminal  
- **Examples**: Web servers, daemons, long-running scripts  
- **Control**: Continue running after terminal closes  

#### 3. **Parent and Child Processes**
- **Parent**: Creates child processes (e.g., shell creates `ls`)  
- **Child**: Inherits properties from parent  
- **Relationship**: PPID (Parent Process ID)  

#### 4. **Orphan Processes**
- **Parent Died**: Child process continues running  
- **Adopted**: Init process (PID 1) becomes new parent  

#### 5. **Zombie Processes**
- **Terminated**: Process finished but entry remains  
- **Waiting**: Parent hasn't collected exit status  
- **Cleanup**: Parent calls `wait()` or exits  

---

### ðŸ”¹ Types of Jobs

#### 1. **Foreground Jobs**
- **Active**: Currently controlling terminal  
- **Input/Output**: Connected to terminal  
- **Examples**: Editing file with `vim`  

#### 2. **Background Jobs**
- **Running**: No terminal control  
- **Output**: May redirect to files  
- **Examples**: `find / -name "*.log" > logs.txt &`  

#### 3. **Stopped Jobs**
- **Paused**: Suspended execution  
- **Resume**: Can be continued later  
- **Examples**: Ctrl+Z stops foreground job  

---

## Basic Process Management Commands

### ðŸ”¹ Viewing Processes

#### `ps` Command
```bash
ps              # Current shell processes
ps aux          # All processes with details
ps -ef          # Full listing
ps -p 1234      # Specific PID
```

#### `top` Command
```bash
top             # Real-time process monitor
top -u username # User's processes
```

#### `htop` Command (if installed)
```bash
htop            # Enhanced interactive top
```

---

### ðŸ”¹ Controlling Processes

#### `kill` Command
```bash
kill 1234               # Send SIGTERM to PID 1234
kill -9 1234            # Force kill (SIGKILL)
kill -STOP 1234         # Stop process
kill -CONT 1234         # Continue stopped process
```

#### `killall` Command
```bash
killall firefox         # Kill all firefox processes
killall -9 apache2      # Force kill all apache processes
```

#### `pkill` Command
```bash
pkill -f "python script" # Kill by pattern
pkill -u rajat          # Kill user's processes
```

---

### ðŸ”¹ Process Priority

#### `nice` Command
```bash
nice -n 10 command      # Start with lower priority
nice command            # Default nice value
```

#### `renice` Command
```bash
renice -n 5 -p 1234     # Change priority of PID 1234
renice -n -10 -u rajat  # Change all user's processes
```

---

## Understanding Process States

Processes can be in different states during their lifecycle.

### ðŸ”¹ Process States

| State | Code | Description |
|-------|------|-------------|
| **Running** | R | Currently executing on CPU |
| **Sleeping** | S | Waiting for event (interruptible) |
| **Waiting** | D | Uninterruptible sleep (usually I/O) |
| **Stopped** | T | Stopped by job control signal |
| **Zombie** | Z | Terminated, waiting for parent |

### ðŸ”¹ State Transitions
- **New â†’ Ready**: Process created, waiting for CPU  
- **Ready â†’ Running**: Scheduled by kernel  
- **Running â†’ Waiting**: Needs I/O or event  
- **Waiting â†’ Ready**: Event occurred  
- **Running â†’ Terminated**: Process exits  

### ðŸ”¹ Viewing States
```bash
ps aux | head -10
# Look at STAT column: R, S, D, T, Z
```

---

## Job Control Basics

Job control allows managing multiple processes in a shell session.

### ðŸ”¹ Job Control Commands

#### Background Jobs
```bash
command &               # Start in background
jobs                    # List jobs
fg %1                   # Bring job 1 to foreground
bg %1                   # Send job 1 to background
```

#### Stopping and Resuming
```bash
Ctrl+Z                  # Stop foreground job
fg                      # Resume in foreground
bg                      # Resume in background
```

#### Job Management
```bash
jobs -l                 # List jobs with PIDs
kill %1                 # Kill job 1
disown %1               # Remove from job list
```

---

### ðŸ”¹ Job States

| State | Description |
|-------|-------------|
| **Running** | Active in foreground/background |
| **Stopped** | Suspended (Ctrl+Z) |
| **Done** | Completed successfully |
| **Terminated** | Killed or exited with error |

---

## Understanding Process and Thread Management

### ðŸ”¹ Processes vs Threads

#### Processes
- **Heavyweight**: Separate memory space  
- **Independent**: Fault isolation  
- **Communication**: IPC (pipes, sockets, shared memory)  
- **Creation**: `fork()` system call  

#### Threads
- **Lightweight**: Shared memory space  
- **Dependent**: Within process  
- **Communication**: Direct memory access  
- **Creation**: `pthread_create()`  

### ðŸ”¹ Process Hierarchy
- **Init (PID 1)**: Root of process tree  
- **Systemd**: Modern init system  
- **Parent-Child**: Tree structure  
- **Sessions**: Group related processes  

### ðŸ”¹ Thread Management
- **Kernel Threads**: Managed by OS  
- **User Threads**: Library-managed  
- **Scheduling**: Kernel schedules threads  
- **Synchronization**: Mutexes, semaphores  

---

## Exploring with ps Command

`ps` (process status) displays information about processes.

### ðŸ”¹ Basic Usage
```bash
ps              # Current shell processes
```

### ðŸ”¹ Common Options

#### Standard Syntax
```bash
ps [options]
```

#### BSD Style (no dash)
```bash
ps aux          # All processes, user-oriented
ps ax           # All processes, no headers
ps u            # User-oriented format
```

#### UNIX Style (with dash)
```bash
ps -e           # All processes
ps -f           # Full format
ps -l           # Long format
ps -p 123,456   # Specific PIDs
```

---

### ðŸ”¹ Output Fields

| Field | Description |
|-------|-------------|
| **PID** | Process ID |
| **PPID** | Parent Process ID |
| **USER** | Owner username |
| **%CPU** | CPU usage percentage |
| **%MEM** | Memory usage percentage |
| **VSZ** | Virtual memory size (KB) |
| **RSS** | Resident set size (KB) |
| **TTY** | Controlling terminal |
| **STAT** | Process state |
| **START** | Start time |
| **TIME** | CPU time used |
| **COMMAND** | Command with arguments |

---

### ðŸ”¹ Practical Examples

#### View all processes
```bash
ps aux
```

#### Find specific process
```bash
ps aux | grep nginx
```

#### Process tree
```bash
ps -ejH          # Show process hierarchy
ps f             # ASCII art process tree
```

#### Memory usage
```bash
ps aux --sort=-%mem | head
```

#### CPU usage
```bash
ps aux --sort=-%cpu | head
```

#### User's processes
```bash
ps -u rajat
```

---

## Real-Time Monitoring with top

`top` provides real-time system monitoring and process management.

### ðŸ”¹ Starting top
```bash
top             # Default view
top -u username # User's processes
top -p 123,456  # Specific PIDs
```

### ðŸ”¹ top Interface

#### Header Information
```
top - 14:25:30 up 5 days,  3:45,  2 users,  load average: 0.15, 0.08, 0.06
Tasks: 123 total,   1 running, 122 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.5 us,  1.2 sy,  0.0 ni, 96.2 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st
MiB Mem :   7946.0 total,   2345.6 free,   3456.7 used,   2143.7 buff/cache
MiB Swap:   2048.0 total,   1800.0 free,    248.0 used.   4123.4 avail Mem
```

#### Process List
```
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 1234 rajat     20   0  456789  23456   7890 S   5.0   0.3   1:23.45 firefox
 5678 apache    20   0  123456   7890   2345 S   2.1   0.1   0:45.67 httpd
```

---

### ðŸ”¹ Interactive Commands

| Key | Action |
|-----|--------|
| **h** | Help |
| **q** | Quit |
| **k** | Kill process |
| **r** | Renice process |
| **Space** | Refresh |
| **M** | Sort by memory |
| **P** | Sort by CPU |
| **T** | Sort by time |
| **u** | Filter by user |
| **c** | Show command line |
| **1** | Show all CPUs |

---

### ðŸ”¹ Customizing top

#### Configuration File
```bash
~/.toprc        # User configuration
```

#### Command Line Options
```bash
top -d 5        # Update every 5 seconds
top -n 10       # Exit after 10 iterations
top -b          # Batch mode (for scripts)
```

---

## Analyzing Performance Metrics

### ðŸ”¹ CPU Metrics

#### Load Average
- **1-minute, 5-minute, 15-minute averages**  
- **Rule of Thumb**: < 1.0 per CPU core is good  
- **Check**: `uptime` or `cat /proc/loadavg`  

#### CPU Utilization
- **User Time**: Application code  
- **System Time**: Kernel operations  
- **Idle Time**: Available CPU  
- **I/O Wait**: Disk/network waiting  

---

### ðŸ”¹ Memory Metrics

#### Memory Types
- **Physical RAM**: Hardware memory  
- **Virtual Memory**: RAM + Swap  
- **Resident Memory**: Actually in RAM  
- **Shared Memory**: Libraries, shared segments  

#### Memory Usage
```bash
free -h         # Human readable
vmstat 1        # Virtual memory stats
```

---

### ðŸ”¹ I/O Metrics

#### Disk I/O
```bash
iostat -x 1     # Extended I/O stats
iotop           # Real-time I/O monitor
```

#### Network I/O
```bash
iptraf          # Network traffic monitor
nload           # Network load monitor
```

---

### ðŸ”¹ System Performance Tools

#### `vmstat`
```bash
vmstat 1        # Virtual memory stats every second
```

#### `iostat`
```bash
iostat -c 1     # CPU stats
iostat -d 1     # Disk stats
```

#### `sar`
```bash
sar -u 1        # CPU usage history
sar -r 1        # Memory usage history
```

#### `perf`
```bash
perf stat command   # Performance counters
perf top            # System-wide profiling
```

---

## â­ Real-World DevOps Scenarios

### ðŸ”¸ Scenario 1: Troubleshoot High CPU Usage
```bash
# Check load average
uptime

# Find CPU-intensive processes
ps aux --sort=-%cpu | head

# Monitor in real-time
top

# Kill problematic process
kill -9 <PID>
```

---

### ðŸ”¸ Scenario 2: Memory Leak Investigation
```bash
# Check memory usage
free -h

# Find memory-hungry processes
ps aux --sort=-%mem | head

# Monitor memory over time
vmstat 1

# Check for OOM kills
dmesg | grep -i oom
```

---

### ðŸ”¸ Scenario 3: Background Job Management
```bash
# Start backup in background
tar -czf backup.tar.gz /data &

# Check job status
jobs

# Monitor progress
ps aux | grep tar

# Bring to foreground if needed
fg %1
```

---

### ðŸ”¸ Scenario 4: Process Priority Tuning
```bash
# Check current priorities
ps -eo pid,ppid,pri,ni,comm

# Lower priority of CPU-intensive task
renice -n 10 -p <PID>

# Start with low priority
nice -n 19 ./cpu-intensive-script &
```

---

### ðŸ”¸ Scenario 5: Zombie Process Cleanup
```bash
# Find zombie processes
ps aux | awk '{print $8}' | grep -c Z

# Identify zombie parents
ps -eo pid,ppid,stat,cmd | grep Z

# Kill parent process
kill -9 <PPID>
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Process**: Running instance of a program with unique PID  
âœ… **ps aux**: View all processes with details  
âœ… **top**: Real-time monitoring and process management  
âœ… **kill -9**: Force terminate unresponsive processes  
âœ… **nice/renice**: Control process scheduling priority  
âœ… **Jobs**: Foreground/background process groups  
âœ… **States**: R (running), S (sleeping), D (waiting), T (stopped), Z (zombie)  
âœ… **Load Average**: System load indicator (< 1.0 per core is good)  
âœ… **Memory**: Monitor RSS, VSZ, and swap usage  
âœ… **I/O**: Use iostat and iotop for disk/network monitoring  

---

## ðŸ“ Quick Reference: Process Management Commands

```bash
# VIEW PROCESSES
ps aux                          # All processes
ps -ef                          # Full listing
ps -p 1234                      # Specific PID
ps -u rajat                     # User's processes
top                             # Real-time monitor
htop                            # Enhanced top

# CONTROL PROCESSES
kill 1234                       # Terminate PID
kill -9 1234                    # Force kill
killall firefox                 # Kill by name
pkill -f "script.py"            # Kill by pattern

# PRIORITY MANAGEMENT
nice -n 10 command              # Start with priority
renice -n 5 -p 1234             # Change priority

# JOB CONTROL
command &                       # Background job
jobs                            # List jobs
fg %1                           # Foreground job
bg %1                           # Background job
Ctrl+Z                          # Stop job

# PERFORMANCE MONITORING
vmstat 1                        # Memory stats
iostat -x 1                     # I/O stats
sar -u 1                        # CPU history
free -h                         # Memory usage
uptime                          # Load average
```

---

## ðŸš¨ Common Issues & Troubleshooting

### ðŸ”¹ Process Won't Die
- Try `kill` first (SIGTERM)  
- Use `kill -9` (SIGKILL) as last resort  
- Check if process is in D state (uninterruptible)  

### ðŸ”¹ High CPU Usage
- Identify with `top` or `ps aux --sort=-%cpu`  
- Check for infinite loops in code  
- Consider nice values for non-critical processes  

### ðŸ”¹ Memory Issues
- Use `free -h` to check available memory  
- Look for memory leaks with `valgrind`  
- Consider adding swap space  

### ðŸ”¹ Zombie Processes
- Zombies are harmless but indicate parent issues  
- Kill parent process to clean up  
- Check application code for proper child handling  

### ðŸ”¹ Load Average High
- Compare to CPU cores (`nproc`)  
- Identify bottleneck (CPU, memory, I/O)  
- Use `sar` for historical data  

---

## ðŸ“š Further Reading
- `man ps`, `man top`, `man kill`  
- Linux process scheduling  
- System performance tuning guides  
- Advanced monitoring with Prometheus/Grafana  

---

# Day-18

---

## Basic Networking in Linux

Welcome to Day 18! Today, we'll dive into the fundamentals of networking in Linux. Understanding networking is essential for system administration, troubleshooting connectivity issues, and managing network configurations. We'll cover basic concepts, commands, and practical configuration steps.

---

### Overview of Networking Fundamentals

**What is Networking?**
Networking in Linux involves connecting computers and devices to share resources, communicate, and access services. It enables data transfer between systems over various media (wired, wireless, etc.).

**Key Networking Concepts:**
- **IP Address:** Unique identifier for devices on a network (e.g., 192.168.1.100)
- **Subnet Mask:** Defines network boundaries (e.g., 255.255.255.0)
- **Gateway/Default Route:** Router that connects to other networks (e.g., 192.168.1.1)
- **DNS:** Translates domain names to IP addresses (e.g., google.com â†’ 8.8.8.8)
- **MAC Address:** Hardware address of network interface (e.g., 00:1B:44:11:3A:B7)

**Network Layers (Simplified):**
1. **Physical Layer:** Cables, wireless signals
2. **Data Link Layer:** MAC addresses, Ethernet
3. **Network Layer:** IP addresses, routing (IP protocol)
4. **Transport Layer:** TCP/UDP ports
5. **Application Layer:** HTTP, FTP, SSH

**Why Networking Matters in Linux:**
- Remote access via SSH
- File sharing (NFS, Samba)
- Web services (Apache, Nginx)
- System updates and package downloads
- Multi-system administration

---

### Network Types and Protocols

#### Network Types:
1. **Local Area Network (LAN):** Small network, same building (e.g., home/office)
2. **Wide Area Network (WAN):** Large network, multiple locations (e.g., internet)
3. **Wireless LAN (WLAN):** Wi-Fi networks
4. **Virtual Private Network (VPN):** Secure connection over public network

#### Common Protocols:
- **TCP (Transmission Control Protocol):** Reliable, connection-oriented (e.g., HTTP, SSH)
- **UDP (User Datagram Protocol):** Fast, connectionless (e.g., DNS, video streaming)
- **IP (Internet Protocol):** Routing and addressing
- **ICMP (Internet Control Message Protocol):** Network diagnostics (ping)
- **ARP (Address Resolution Protocol):** Maps IP to MAC addresses

#### Port Numbers:
- **Well-known Ports:** 0-1023 (e.g., 22=SSH, 80=HTTP, 443=HTTPS)
- **Registered Ports:** 1024-49151
- **Dynamic Ports:** 49152-65535

**Example Services and Ports:**
- SSH: 22
- HTTP: 80
- HTTPS: 443
- FTP: 21
- DNS: 53

---

### Using ifconfig and ip Commands

These are essential commands for viewing and managing network interfaces.

#### ifconfig Command (Deprecated but still used):
**Purpose:** Configure and display network interface information

**Basic Usage:**
```bash
# Show all interfaces
ifconfig

# Show specific interface
ifconfig eth0

# Bring interface up/down
sudo ifconfig eth0 up
sudo ifconfig eth0 down

# Set IP address temporarily
sudo ifconfig eth0 192.168.1.100 netmask 255.255.255.0
```

**Sample Output:**
```bash
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::a00:27ff:fe4e:66a1  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:4e:66:a1  txqueuelen 1000  (Ethernet)
        RX packets 12345  bytes 1234567 (1.2 MB)
        TX packets 6789  bytes 987654 (987.6 KB)
```

#### ip Command (Modern replacement for ifconfig):
**Purpose:** Show and manipulate routing, devices, policy routing, and tunnels

**Basic Usage:**
```bash
# Show all interfaces
ip addr show
ip a  # Short form

# Show specific interface
ip addr show eth0

# Show routing table
ip route show
ip r  # Short form

# Bring interface up/down
sudo ip link set eth0 up
sudo ip link set eth0 down

# Set IP address temporarily
sudo ip addr add 192.168.1.100/24 dev eth0
sudo ip addr del 192.168.1.100/24 dev eth0
```

**Sample Output:**
```bash
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:4e:66:a1 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic eth0
       valid_lft 86399sec preferred_lft 86399sec
```

**Key Differences:**
- `ifconfig`: Older, simpler, being phased out
- `ip`: Modern, more powerful, part of iproute2 suite

---

### Basic Network Configuration Steps

#### 1. Identify Network Interfaces:
```bash
ip a
# or
ifconfig
```

#### 2. Check Current Configuration:
```bash
# IP address, subnet, gateway
ip addr show

# Routing table
ip route show

# DNS servers
cat /etc/resolv.conf
```

#### 3. Test Connectivity:
```bash
# Ping local gateway
ping -c 4 192.168.1.1

# Ping external host
ping -c 4 google.com

# Test DNS resolution
nslookup google.com
```

#### 4. Configure Network (Temporary):
```bash
# Set IP address
sudo ip addr add 192.168.1.100/24 dev eth0

# Set default gateway
sudo ip route add default via 192.168.1.1

# Set DNS
echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf
```

#### 5. Make Changes Permanent:
Use NetworkManager (nmcli/nmtui) or edit configuration files directly.

---

### Configuring Static IP with nmtui and nmcli

NetworkManager provides user-friendly tools for network configuration.

#### Using nmtui (Text-based UI):
**nmtui** provides a simple text interface for network configuration.

```bash
# Launch nmtui
sudo nmtui

# Navigate with arrow keys and Enter
# 1. Select "Edit a connection"
# 2. Choose your network interface (e.g., eth0)
# 3. Select "Edit"
# 4. Change IPv4 Configuration to "Manual"
# 5. Enter IP Address, Netmask, Gateway
# 6. Enter DNS servers
# 7. Select "OK" and "Back"
# 8. Select "Activate a connection" if needed
# 9. Quit
```

#### Using nmcli (Command Line):
**nmcli** is the command-line tool for NetworkManager.

**Basic Commands:**
```bash
# List connections
nmcli connection show

# Show device status
nmcli device status

# Modify connection (replace 'eth0' with your interface)
sudo nmcli connection modify eth0 ipv4.method manual
sudo nmcli connection modify eth0 ipv4.addresses 192.168.1.100/24
sudo nmcli connection modify eth0 ipv4.gateway 192.168.1.1
sudo nmcli connection modify eth0 ipv4.dns "8.8.8.8 8.8.4.4"

# Bring connection down and up to apply changes
sudo nmcli connection down eth0
sudo nmcli connection up eth0
```

**View Configuration:**
```bash
# Show connection details
nmcli connection show eth0
```

---

### Example: Configuring a Static IP Address and Verifying Network Connectivity

#### Scenario:
Configure eth0 with static IP 192.168.1.100, subnet 255.255.255.0, gateway 192.168.1.1, DNS 8.8.8.8

#### Step-by-Step Configuration:

1. **Check Current Configuration:**
   ```bash
   ip addr show eth0
   ip route show
   cat /etc/resolv.conf
   ```

2. **Configure with nmcli:**
   ```bash
   sudo nmcli connection modify eth0 ipv4.method manual
   sudo nmcli connection modify eth0 ipv4.addresses 192.168.1.100/24
   sudo nmcli connection modify eth0 ipv4.gateway 192.168.1.1
   sudo nmcli connection modify eth0 ipv4.dns "8.8.8.8"
   ```

3. **Apply Changes:**
   ```bash
   sudo nmcli connection down eth0
   sudo nmcli connection up eth0
   ```

4. **Verify Configuration:**
   ```bash
   # Check IP address
   ip addr show eth0
   
   # Check routing
   ip route show
   
   # Check DNS
   cat /etc/resolv.conf
   ```

5. **Test Connectivity:**
   ```bash
   # Ping gateway
   ping -c 4 192.168.1.1
   
   # Ping external host
   ping -c 4 google.com
   
   # Test DNS
   nslookup google.com
   
   # Test internet connectivity
   curl -I https://www.google.com
   ```

6. **Troubleshooting if Issues Occur:**
   ```bash
   # Check NetworkManager status
   systemctl status NetworkManager
   
   # Restart NetworkManager
   sudo systemctl restart NetworkManager
   
   # Check logs
   journalctl -u NetworkManager -n 20
   ```

#### Alternative: Using nmtui:
```bash
sudo nmtui
# Follow the menu to set static IP as described earlier
```

---

## Hands-On Exercises for Students

1. **Explore Network Interfaces:**
   ```bash
   # List all interfaces
   ip a
   
   # Show routing table
   ip route show
   
   # Check DNS configuration
   cat /etc/resolv.conf
   ```

2. **Test Connectivity:**
   ```bash
   # Ping local gateway (find gateway first with ip route)
   ping -c 4 [gateway-ip]
   
   # Ping external host
   ping -c 4 google.com
   
   # Test DNS resolution
   host google.com
   ```

3. **Configure Static IP with nmcli:**
   ```bash
   # Backup current connection
   sudo nmcli connection show
   
   # Modify connection (use your interface name)
   sudo nmcli connection modify [interface] ipv4.method manual
   sudo nmcli connection modify [interface] ipv4.addresses 192.168.1.200/24
   sudo nmcli connection modify [interface] ipv4.gateway 192.168.1.1
   sudo nmcli connection modify [interface] ipv4.dns "8.8.8.8"
   
   # Apply changes
   sudo nmcli connection down [interface]
   sudo nmcli connection up [interface]
   
   # Verify
   ip addr show [interface]
   ping -c 4 google.com
   ```

4. **Use nmtui for Configuration:**
   ```bash
   sudo nmtui
   # Follow the interface to set static IP
   # Test connectivity after
   ```

5. **Network Troubleshooting:**
   ```bash
   # Check interface status
   nmcli device status
   
   # Check connection status
   nmcli connection show
   
   # Restart networking
   sudo systemctl restart NetworkManager
   
   # Test with different tools
   traceroute google.com
   dig google.com
   ```

---

## Quick Reference Cheat-Sheet

### Network Commands:
- `ip addr show` â€” Show IP addresses
- `ip route show` â€” Show routing table
- `ping host` â€” Test connectivity
- `nslookup host` â€” DNS lookup
- `traceroute host` â€” Trace network path

### NetworkManager Commands:
- `nmcli connection show` â€” List connections
- `nmcli device status` â€” Show device status
- `sudo nmtui` â€” Text UI for configuration
- `nmcli connection modify` â€” Modify connection

### Configuration Files:
- `/etc/resolv.conf` â€” DNS servers
- `/etc/hosts` â€” Local hostname resolution
- `/etc/network/interfaces` â€” Static config (older systems)

### Common Issues:
- No internet: Check gateway and DNS
- IP conflict: Use different IP address
- DNS issues: Check /etc/resolv.conf

---

## Key Takeaways for Students

- Networking fundamentals include IP addresses, subnets, gateways, and DNS.
- Use `ip` command for modern network management; `ifconfig` is legacy.
- NetworkManager tools (nmcli, nmtui) simplify configuration.
- Always test connectivity after configuration changes.
- Static IP configuration requires IP, subnet mask, gateway, and DNS.

Remember, networking is crucial for Linux administration. Practice these commands in a safe environment before applying to production systems!

---
